<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatalpaFlat&#39;s Blogs</title>
  
  <subtitle>CatalpaFlat</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://catalpaflat.github.io/"/>
  <updated>2018-03-28T13:31:13.256Z</updated>
  <id>https://catalpaflat.github.io/</id>
  
  <author>
    <name>CatalpaFlat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker run 命令</title>
    <link href="https://catalpaflat.github.io/2018/02/05/docker/%E5%91%BD%E4%BB%A4/run/"/>
    <id>https://catalpaflat.github.io/2018/02/05/docker/命令/run/</id>
    <published>2018-02-05T14:33:12.000Z</published>
    <updated>2018-03-28T13:31:13.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-run-命令"><a href="#Docker-run-命令" class="headerlink" title="Docker run 命令"></a>Docker run 命令</h1><blockquote><p>docker run ：创建一个新的容器并运行一个命令</p></blockquote><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h3 id="1-1-OPTIONS说明"><a href="#1-1-OPTIONS说明" class="headerlink" title="1.1. OPTIONS说明"></a>1.1. OPTIONS说明</h3><ol><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=”ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">Run a command in a new container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host value              Add a custom host-to-IP mapping (host:ip) (default [])</span><br><span class="line">  -a, --attach value                Attach to STDIN, STDOUT or STDERR (default [])</span><br><span class="line">      --blkio-weight value          Block IO (relative weight), between 10 and 1000</span><br><span class="line">      --blkio-weight-device value   Block IO weight (relative device weight) (default [])</span><br><span class="line">      --cap-add value               Add Linux capabilities (default [])</span><br><span class="line">      --cap-drop value              Drop Linux capabilities (default [])</span><br><span class="line">      --cgroup-parent string        Optional parent cgroup for the container</span><br><span class="line">      --cidfile string              Write the container ID to the file</span><br><span class="line">      --cpu-percent int             CPU percent (Windows only)</span><br><span class="line">      --cpu-period int              Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int               Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">  -c, --cpu-shares int              CPU shares (relative weight)</span><br><span class="line">      --cpuset-cpus string          CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string          MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">  -d, --detach                      Run container in background and print container ID</span><br><span class="line">      --detach-keys string          Override the key sequence for detaching a container</span><br><span class="line">      --device value                Add a host device to the container (default [])</span><br><span class="line">      --device-read-bps value       Limit read rate (bytes per second) from a device (default [])</span><br><span class="line">      --device-read-iops value      Limit read rate (IO per second) from a device (default [])</span><br><span class="line">      --device-write-bps value      Limit write rate (bytes per second) to a device (default [])</span><br><span class="line">      --device-write-iops value     Limit write rate (IO per second) to a device (default [])</span><br><span class="line">      --disable-content-trust       Skip image verification (default true)</span><br><span class="line">      --dns value                   Set custom DNS servers (default [])</span><br><span class="line">      --dns-opt value               Set DNS options (default [])</span><br><span class="line">      --dns-search value            Set custom DNS search domains (default [])</span><br><span class="line">      --entrypoint string           Overwrite the default ENTRYPOINT of the image</span><br><span class="line">  -e, --env value                   Set environment variables (default [])</span><br><span class="line">      --env-file value              Read in a file of environment variables (default [])</span><br><span class="line">      --expose value                Expose a port or a range of ports (default [])</span><br><span class="line">      --group-add value             Add additional groups to join (default [])</span><br><span class="line">      --health-cmd string           Command to run to check health</span><br><span class="line">      --health-interval duration    Time between running the check (default 0s)</span><br><span class="line">      --health-retries int          Consecutive failures needed to report unhealthy</span><br><span class="line">      --health-timeout duration     Maximum time to allow one check to run (default 0s)</span><br><span class="line">      --help                        Print usage</span><br><span class="line">  -h, --hostname string             Container host name</span><br><span class="line">  -i, --interactive                 Keep STDIN open even if not attached</span><br><span class="line">      --io-maxbandwidth string      Maximum IO bandwidth limit for the system drive (Windows only)</span><br><span class="line">      --io-maxiops uint             Maximum IOps limit for the system drive (Windows only)</span><br><span class="line">      --ip string                   Container IPv4 address (e.g. 172.30.100.104)</span><br><span class="line">      --ip6 string                  Container IPv6 address (e.g. 2001:db8::33)</span><br><span class="line">      --ipc string                  IPC namespace to use</span><br><span class="line">      --isolation string            Container isolation technology</span><br><span class="line">      --kernel-memory string        Kernel memory limit</span><br><span class="line">  -l, --label value                 Set meta data on a container (default [])</span><br><span class="line">      --label-file value            Read in a line delimited file of labels (default [])</span><br><span class="line">      --link value                  Add link to another container (default [])</span><br><span class="line">      --link-local-ip value         Container IPv4/IPv6 link-local addresses (default [])</span><br><span class="line">      --log-driver string           Logging driver for the container</span><br><span class="line">      --log-opt value               Log driver options (default [])</span><br><span class="line">      --mac-address string          Container MAC address (e.g. 92:d0:c6:0a:29:33)</span><br><span class="line">  -m, --memory string               Memory limit</span><br><span class="line">      --memory-reservation string   Memory soft limit</span><br><span class="line">      --memory-swap string          Swap limit equal to memory plus swap: '-1' to enable unlimited swap</span><br><span class="line">      --memory-swappiness int       Tune container memory swappiness (0 to 100) (default -1)</span><br><span class="line">      --name string                 Assign a name to the container</span><br><span class="line">      --network string              Connect a container to a network (default "default")</span><br><span class="line">      --network-alias value         Add network-scoped alias for the container (default [])</span><br><span class="line">      --no-healthcheck              Disable any container-specified HEALTHCHECK</span><br><span class="line">      --oom-kill-disable            Disable OOM Killer</span><br><span class="line">      --oom-score-adj int           Tune host's OOM preferences (-1000 to 1000)</span><br><span class="line">      --pid string                  PID namespace to use</span><br><span class="line">      --pids-limit int              Tune container pids limit (set -1 for unlimited)</span><br><span class="line">      --privileged                  Give extended privileges to this container</span><br><span class="line">  -p, --publish value               Publish a container's port(s) to the host (default [])</span><br><span class="line">  -P, --publish-all                 Publish all exposed ports to random ports</span><br><span class="line">      --read-only                   Mount the container's root filesystem as read only</span><br><span class="line">      --restart string              Restart policy to apply when a container exits (default "no")</span><br><span class="line">      --rm                          Automatically remove the container when it exits</span><br><span class="line">      --runtime string              Runtime to use for this container</span><br><span class="line">      --security-opt value          Security Options (default [])</span><br><span class="line">      --shm-size string             Size of /dev/shm, default value is 64MB</span><br><span class="line">      --sig-proxy                   Proxy received signals to the process (default true)</span><br><span class="line">      --stop-signal string          Signal to stop a container, SIGTERM by default (default "SIGTERM")</span><br><span class="line">      --storage-opt value           Storage driver options for the container (default [])</span><br><span class="line">      --sysctl value                Sysctl options (default map[])</span><br><span class="line">      --tmpfs value                 Mount a tmpfs directory (default [])</span><br><span class="line">  -t, --tty                         Allocate a pseudo-TTY</span><br><span class="line">      --ulimit value                Ulimit options (default [])</span><br><span class="line">  -u, --user string                 Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">      --userns string               User namespace to use</span><br><span class="line">      --uts string                  UTS namespace to use</span><br><span class="line">  -v, --volume value                Bind mount a volume (default [])</span><br><span class="line">      --volume-driver string        Optional volume driver for the container</span><br><span class="line">      --volumes-from value          Mount volumes from the specified container(s) (default [])</span><br><span class="line">  -w, --workdir string              Working directory inside the container</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-run-命令&quot;&gt;&lt;a href=&quot;#Docker-run-命令&quot; class=&quot;headerlink&quot; title=&quot;Docker run 命令&quot;&gt;&lt;/a&gt;Docker run 命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;docker run ：创
      
    
    </summary>
    
      <category term="docker" scheme="https://catalpaflat.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://catalpaflat.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Java 编码规范</title>
    <link href="https://catalpaflat.github.io/2018/01/23/java/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://catalpaflat.github.io/2018/01/23/java/Java开发规范/</id>
    <published>2018-01-23T05:20:56.000Z</published>
    <updated>2018-03-28T12:57:49.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-编码规范"><a href="#Java-编码规范" class="headerlink" title="Java 编码规范"></a>Java 编码规范</h1><blockquote><p>编写时间：2018.01.20<br>编写人：CatalpaFlat</p></blockquote><h2 id="第1章-序言"><a href="#第1章-序言" class="headerlink" title="第1章    序言"></a>第1章    序言</h2><p>&emsp;&emsp;本规范的目的在于：建立一个可行可操作的编程标准、约定和指南，以规范公司java代码研发工作。<br>&emsp;&emsp;为了提高公司研发能力，该规范的制定是为了规范java代码开发，提高java开发质量，从代码的层面规范并提高java项目的研发水平。该规范由Java技术小组制定，组织技术人员对重点项目以及新的java项目定期检查，对代码质量进行评估，对代码质量较差限期整改，并报Java技术小组组长备案作为项目考核依据。<br>&emsp;&emsp;本规范的内容包括两个方面：编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六个维度。再根据内容特征，细分成若干二级子目录。<br>&emsp;&emsp;为了开发者针对违规代码进行调整，根据约束力强弱及故障敏感性：  </p><ul><li>规约级别：强制、推荐、参考三大类；<ul><li>“说明”：对内容做了适当扩展和解释，对于规约条目的延伸信息中；</li><li>“正例”：提倡什么样的编码和实现方式；</li><li>“反例”：说明需要提防的雷区，以及真实的错误案例。  </li></ul></li></ul><p>&emsp;&emsp;本规范解释权归Java技术小组，属于Java技术小组为了提供公司研发水平以及质量的一系列措施中的一部分，在后续的版本中将根据具体需要进行修改以及调整。技术小组审核后给出相应的整改意见，对于有争议的问题，可直接与Java技术小组组长沟通。   </p><h2 id="第2章-编程规约"><a href="#第2章-编程规约" class="headerlink" title="第2章    编程规约"></a>第2章    编程规约</h2><h3 id="2-1-命名规范"><a href="#2-1-命名规范" class="headerlink" title="2.1    命名规范"></a>2.1    命名规范</h3><p>1.【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<br>&emsp;反例：<em>name/__name/$Object/name</em>/name$/Object$<br>2.【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br>&emsp;说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。<br>&emsp;正例：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。<br>&emsp;反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3<br>3.【强制】类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO / TO<br>&emsp;正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>&emsp;反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion<br>4.【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。<br>&emsp;正例： localValue / getHttpMessage() / inputUserId<br>5.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>&emsp;正例：MAX_STOCK_COUNT<br>&emsp;反例：MAX_COUNT<br>6.【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。<br>7.【强制】中括号是数组类型的一部分，<br>&emsp;正例：数组定义如下：String[] args;<br>&emsp;反例：使用String args[]的方式来定义。<br>8.【强制】POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。<br>&emsp;反例：定义为基本数据类型Boolean isDeleted；的属性，它的方法也是isDeleted()，RPC框架在反向解析的时候，“以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。<br>9.【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br>&emsp;正例： 应用工具类包名为com.alibaba.open.util、类名为MessageUtils（此规则参考spring的框架结构）<br>10.【强制】杜绝完全不规范的缩写，避免望文不知义。<br>&emsp;反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。<br>11.【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。<br>&emsp;正例：从远程仓库拉取代码的类命名为PullCodeFromRemoteRepository。<br>&emsp;反例：变量int a; 的随意命名方式。<br>12.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。<br>&emsp;说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br>&emsp;正例：public class OrderFactory; public class LoginProxy; public class ResourceObserver;<br>13.【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。<br>&emsp;正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = “alibaba”;<br>&emsp;反例：接口方法定义：public abstract void f();<br>&emsp;说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。<br>14.接口和实现类的命名有两套规则：<br> &emsp;1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。<br>&emsp;&emsp;正例：CacheServiceImpl实现CacheService接口。<br>&emsp; 2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。<br>&emsp;&emsp;正例：AbstractTranslator实现 Translatable。<br>15.【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>&emsp;说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>&emsp;正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKOWN_REASON。<br>16.【参考】各层命名规约：<br>&emsp;A) Service/DAO层方法命名规约:<br>&emsp;&emsp;1） 获取单个对象的方法用get做前缀。<br>&emsp;&emsp;2） 获取多个对象的方法用list做前缀。<br>&emsp;&emsp;3） 获取统计值的方法用count做前缀。<br>&emsp;&emsp;4） 插入的方法用save/insert做前缀。<br>&emsp;&emsp;5） 删除的方法用remove/delete做前缀。<br>&emsp;&emsp;6） 修改的方法用update做前缀。<br>&emsp;B) 领域模型命名规约:<br>&emsp;&emsp;1） 数据对象：xxxDO，xxx即为数据表名。<br>&emsp;&emsp;2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。<br>&emsp;&emsp;3） 展示对象：xxxVO，xxx一般为网页名称。<br>&emsp;&emsp;4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。  </p><h3 id="2-2-常量定义"><a href="#2-2-常量定义" class="headerlink" title="2.2    常量定义"></a>2.2    常量定义</h3><p>1.【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。<br>&emsp;反例：String key = “Id#taobao_” + tradeId; cache.put(key, value);<br>2.【强制】long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。<br>&emsp;说明：Long a = 2l; 写的是数字的21，还是Long型的2?<br>3.【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。<br>&emsp;说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。<br>&emsp;正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。<br>4.【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<br>&emsp;1） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。<br>&emsp;2） 应用内共享常量：放置在一方库中，通常是modules中的constant目录下。<br>&emsp;反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//类A中：</span><br><span class="line">public static final String YES = &quot;yes&quot;;</span><br><span class="line">//类B中：</span><br><span class="line">public static final String YES = &quot;y&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A.YES.equals(B.YES);//预期是true，但实际返回为false，导致线上问题。  </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&amp;emsp;3） 子工程内部共享常量：即在当前子工程的constant目录下。  </span><br><span class="line">&amp;emsp;4） 包内共享常量：即在当前包下单独的constant目录下。  </span><br><span class="line">&amp;emsp;5） 类内共享常量：直接在类内部private static final定义。  </span><br><span class="line"></span><br><span class="line">5.【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。  </span><br><span class="line">正例：</span><br></pre></td></tr></table></figure><pre><code>public Enum {    MONDAY(1),    TUESDAY(2),    WEDNESDAY(3),    THURSDAY(4),    FRIDAY(5),    SATURDAY(6),    SUNDAY(7);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.3代码格式</span><br><span class="line">1.【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成&#123;&#125;即可，不需要换行；如果是非空代码块则：  </span><br><span class="line">&amp;emsp;1） 左大括号前不换行。  </span><br><span class="line">&amp;emsp;2） 左大括号后换行。  </span><br><span class="line">&amp;emsp;3） 右大括号前换行。  </span><br><span class="line">&amp;emsp;4） 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。   </span><br><span class="line">2.【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第5条下方正例提示。  </span><br><span class="line">&amp;emsp;反例：if (空格a == b空格)  </span><br><span class="line">3.【强制】if/for/while/switch/do等保留字与括号之间都必须加空格。  </span><br><span class="line">4.【强制】任何二目、三目运算符的左右两边都需要加一个空格。   </span><br><span class="line">&amp;emsp;说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。   </span><br><span class="line">5.【强制】采用4个空格缩进，禁止使用tab字符。  </span><br><span class="line">&amp;emsp;说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。    </span><br><span class="line">&amp;emsp;正例： （涉及1-5点）</span><br></pre></td></tr></table></figure><pre><code>public static void main(String[] args) {    // 缩进4个空格    String say = &quot;hello&quot;;    // 运算符的左右必须有一个空格    int flag = 0;    // 关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格    if (flag == 0) {      System.out.println(say);    }    // 左大括号前加空格且不换行；左大括号后换行    if (flag == 1) {      System.out.println(&quot;world&quot;);      // 右大括号前换行，右大括号后有else，不用换行    } else {      System.out.println(&quot;ok&quot;);      // 在右大括号后直接结束，则必须换行    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6.【强制】注释的双斜线与注释内容之间有且仅有一个空格。    </span><br><span class="line">&amp;emsp;正例：// 注释内容，注意在//和注释内容之间有一个空格。  </span><br><span class="line">7.【强制】单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则：    </span><br><span class="line">&amp;emsp;1） 第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例。    </span><br><span class="line">&amp;emsp;2） 运算符与下文一起换行。  </span><br><span class="line">&amp;emsp;3） 方法调用的点符号与下文一起换行。  </span><br><span class="line">&amp;emsp;4） 方法调用时，多个参数，需要换行时，在逗号后进行。  </span><br><span class="line">&amp;emsp;5） 在括号前不要换行，见反例。  </span><br><span class="line">&amp;emsp;正例：</span><br></pre></td></tr></table></figure><pre><code>StringBuffer sb = new StringBuffer();// 超过120个字符的情况下，换行缩进4个空格，点号和方法名称一起换行sb.append(&quot;zi&quot;).append(&quot;xin&quot;)....append(&quot;huang&quot;)....append(&quot;huang&quot;)....append(&quot;huang&quot;);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;反例：</span><br></pre></td></tr></table></figure><pre><code>StringBuffer sb = new StringBuffer();// 超过120个字符的情况下，不要在括号前换行sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append(&quot;huang&quot;);// 参数很多的方法调用可能超过120个字符，不要在逗号前换行method(args1, args2, args3, ..., argsX);  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。  </span><br><span class="line">&amp;emsp;正例：下例中实参的&quot;a&quot;,后边必须要有一个空格。</span><br></pre></td></tr></table></figure><pre><code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9.【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用Windows格式。  </span><br><span class="line">10.【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。  </span><br><span class="line">&amp;emsp;正例：</span><br></pre></td></tr></table></figure><pre><code>int a = 3;long b = 4L;float c = 5F;StringBuffer sb = new StringBuffer();</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;说明：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。  </span><br><span class="line">11.【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。  </span><br><span class="line">&amp;emsp;说明：没有必要插入多个空行进行隔开。      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.4OOP规约</span><br><span class="line">1.【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。    </span><br><span class="line">2.【强制】所有的覆写方法，必须加@Override注解。  </span><br><span class="line">&amp;emsp;说明：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。  </span><br><span class="line">3.【强制】相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。  </span><br><span class="line">&amp;emsp;说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）  </span><br><span class="line">正例：</span><br></pre></td></tr></table></figure><pre><code>public User getUsers(String type, Integer... ids) {...}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。    </span><br><span class="line">5.【强制】不能使用过时的类或方法。  </span><br><span class="line">&amp;emsp;说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。  </span><br><span class="line">6.【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。  </span><br><span class="line">&amp;emsp;正例：&quot;test&quot;.equals(object);  </span><br><span class="line">&amp;emsp;反例：object.equals(&quot;test&quot;);  </span><br><span class="line">&amp;emsp;说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）  </span><br><span class="line">7.【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。  </span><br><span class="line">&amp;emsp;说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。  </span><br><span class="line">8.关于基本数据类型与包装数据类型的使用标准如下：  </span><br><span class="line">&amp;emsp;1） 【强制】所有的POJO类属性必须使用包装数据类型。  </span><br><span class="line">&amp;emsp;2） 【强制】RPC方法的返回值和参数必须使用包装数据类型。  </span><br><span class="line">&amp;emsp;3） 【推荐】所有的局部变量使用基本数据类型。  </span><br><span class="line">&amp;emsp;说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。  </span><br><span class="line">&amp;emsp;正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。  </span><br><span class="line">&amp;emsp;反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。  </span><br><span class="line">9.【强制】定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。  </span><br><span class="line">&amp;emsp;反例：POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。   </span><br><span class="line">10.【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。  </span><br><span class="line">&amp;emsp;说明：注意serialVersionUID不一致会抛出序列化运行时异常。    </span><br><span class="line">11.【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。   </span><br><span class="line">12.【强制】POJO类必须写toString方法。使用IDE的中工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。   </span><br><span class="line">&amp;emsp;说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。  </span><br><span class="line">13.【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。   </span><br><span class="line">&amp;emsp;说明：</span><br></pre></td></tr></table></figure><pre><code>String str = &quot;a,b,c,,&quot;;String[] ary = str.split(&quot;,&quot;);// 预期大于3，结果是3System.out.println(ary.length);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">14.【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第15条规则。  </span><br><span class="line">15.【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。  </span><br><span class="line">&amp;emsp;说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。     </span><br><span class="line">16.【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度。  </span><br><span class="line">&amp;emsp;反例：</span><br></pre></td></tr></table></figure><pre><code>public Integer getData() {    if (true) {        return this.data + 100;    } else {        return this.data - 100;    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">17.【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。  </span><br><span class="line">&amp;emsp;说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。   </span><br><span class="line">&amp;emsp;反例：</span><br></pre></td></tr></table></figure><pre><code>String str = &quot;start&quot;;for (int i = 0; i &lt; 100; i++) {str = str + &quot;hello&quot;;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">18.【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字：  </span><br><span class="line">&amp;emsp;1） 不允许被继承的类，如：String类。  </span><br><span class="line">&amp;emsp;2） 不允许修改引用的域对象，如：POJO类的域变量。  </span><br><span class="line">&amp;emsp;3） 不允许被重写的方法，如：POJO类的setter方法。  </span><br><span class="line">&amp;emsp;4） 不允许运行过程中重新赋值的局部变量。  </span><br><span class="line">&amp;emsp;5） 避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。   </span><br><span class="line">19.【推荐】慎用Object的clone方法来拷贝对象。  </span><br><span class="line">&amp;emsp;说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。   </span><br><span class="line">20.【推荐】类成员与方法访问控制从严：   </span><br><span class="line">&amp;emsp;1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。  </span><br><span class="line">&amp;emsp;2） 工具类不允许有public或default构造方法。  </span><br><span class="line">&amp;emsp;3） 类非static成员变量并且与子类共享，必须是protected。  </span><br><span class="line">&amp;emsp;4） 类非static成员变量并且仅在本类使用，必须是private。  </span><br><span class="line">&amp;emsp;5） 类static成员变量如果仅在本类使用，必须是private。  </span><br><span class="line">&amp;emsp;6） 若是static成员变量，必须考虑是否为final。  </span><br><span class="line">&amp;emsp;7） 类成员方法只供类内部调用，必须是private。  </span><br><span class="line">&amp;emsp;8） 类成员方法只对继承类公开，那么限制为protected。  </span><br><span class="line">&amp;emsp;说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service方法，或者一个public的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.5集合规约  </span><br><span class="line">1.【强制】关于hashCode和equals的处理，遵循如下规则：  </span><br><span class="line">&amp;emsp;1） 只要重写equals，就必须重写hashCode。  </span><br><span class="line">&amp;emsp;2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。  </span><br><span class="line">&amp;emsp;3） 如果自定义对象做为Map的键，那么必须重写hashCode和equals。</span><br><span class="line">说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。  </span><br><span class="line">2.【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.   </span><br><span class="line">&amp;emsp;说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。  </span><br><span class="line">3.【强制】在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常。  </span><br><span class="line">4.【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。  </span><br><span class="line">&amp;emsp;说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。  </span><br><span class="line">&amp;emsp;正例：</span><br></pre></td></tr></table></figure><pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);list.add(&quot;guan&quot;);list.add(&quot;bao&quot;);String[] array = new String[list.size()];array = list.toArray(array);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。  </span><br><span class="line">5.【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出 UnsupportedOperationException异常。  </span><br><span class="line">&amp;emsp;说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</span><br></pre></td></tr></table></figure><pre><code>String[] str = new String[] { &quot;you&quot;, &quot;wu&quot; };List list = Arrays.asList(str);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;第一种情况：list.add(&quot;yangguanbao&quot;); 运行时异常。  </span><br><span class="line">&amp;emsp;&amp;emsp;第二种情况：str[0] = &quot;gujin&quot;; 那么list.get(0)也会随之修改。  </span><br><span class="line">6.【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，而&lt;? super T&gt;不能使用get方法，做为接口调用赋值时易出错。  </span><br><span class="line">&amp;emsp;说明：扩展说一下PECS(Producer Extends Consumer Super)原则：  </span><br><span class="line">&amp;emsp;&amp;emsp;第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。  </span><br><span class="line">&amp;emsp;&amp;emsp;第二、经常往里插入的，适合用&lt;? super T&gt;。  </span><br><span class="line">7.【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。  </span><br><span class="line">&amp;emsp;正例：</span><br></pre></td></tr></table></figure><p>  Iterator<string> iterator = list.iterator();<br>    while (iterator.hasNext()) {<br>      String item = iterator.next();<br>      if (删除元素的条件) {<br>        iterator.remove();<br>      }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;反例：</span><br></pre></td></tr></table></figure></string></p><pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;1&quot;);list.add(&quot;2&quot;);for (String item : list) {  if (&quot;1&quot;.equals(item)) {     list.remove(item);  }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？  </span><br><span class="line">8.【强制】 在JDK7版本及以上，Comparator要满足如下三个条件，不然Arrays.sort，Collections.sort会报IllegalArgumentException异常。  </span><br><span class="line">&amp;emsp;说明：三个条件如下  </span><br><span class="line">&amp;emsp;&amp;emsp;1） x，y的比较结果和y，x的比较结果相反。  </span><br><span class="line">&amp;emsp;&amp;emsp;2） x&gt;y，y&gt;z，则x&gt;z。  </span><br><span class="line">&amp;emsp;&amp;emsp;3） x=y，则x，z比较结果和y，z比较结果相同。  </span><br><span class="line">&amp;emsp;反例：下例中没有处理相等的情况，实际使用中可能会出现异常：</span><br></pre></td></tr></table></figure><pre><code>new Comparator&lt;Student&gt;() {    @Override    public int compare(Student o1, Student o2) {        return o1.getId() &gt; o2.getId() ? 1 : -1;    }};</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9.【推荐】集合初始化时，指定集合初始值大小。  </span><br><span class="line">&amp;emsp;说明：HashMap使用HashMap(int initialCapacity) 初始化，  </span><br><span class="line">&amp;emsp;正例：initialCapacity =(需要存储的元素个数 / 负载因子) + 1。注意负载因子（即loader factor）默认为0.75，如果暂时无法确定初始值大小，请设置为16（即默认值）。  </span><br><span class="line">&amp;emsp;反例：HashMap需要放置1024个元素，由于没有设置容量初始大小，随着元素不断增加，容量7次被迫扩大，resize需要重建hash表，严重影响性能。  </span><br><span class="line">10.【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。  </span><br><span class="line">&amp;emsp;说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。</span><br><span class="line">&amp;emsp;正例：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。  </span><br><span class="line">11.【推荐】高度注意Map类集合K/V能不能存储null值的情况，如下表格：  </span><br><span class="line"></span><br><span class="line">| 集合类 | Key |Value |Super |说明</span><br><span class="line">|----|----|----|----|----|</span><br><span class="line">|Hashtable |不允许为null|不允许为null |Dictionary| 线程安全</span><br><span class="line">|ConcurrentHashMap |不允许为null |不允许为null |AbstractMap |锁分段技术（JDK8:CAS）</span><br><span class="line">|TreeMap |不允许为null| 允许为null |AbstractMap |线程不安全</span><br><span class="line">|HashMap |允许为null |允许为null |AbstractMap |线程不安全</span><br><span class="line">&amp;emsp;反例： 由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上，存储null值时会抛出NPE异常。  </span><br><span class="line">12.【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。   </span><br><span class="line">&amp;emsp;说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。  </span><br><span class="line">13.【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作。   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.6 并发规约</span><br><span class="line">1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。  </span><br><span class="line">&amp;emsp;说明：资源驱动类、工具类、单例工厂类都需要注意。  </span><br><span class="line">2.【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。  </span><br><span class="line">&amp;emsp;正例：</span><br></pre></td></tr></table></figure><pre><code>public class TimerTaskThread extends Thread {    public TimerTaskThread() {      super.setName(&quot;TimerTaskThread&quot;);      ...    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。  </span><br><span class="line">&amp;emsp;说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。  </span><br><span class="line"></span><br><span class="line">4.【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。  </span><br><span class="line">&amp;emsp;说明：Executors返回的线程池对象的弊端如下：  </span><br><span class="line">&amp;emsp;&amp;emsp;1）FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。  </span><br><span class="line">&amp;emsp;&amp;emsp;2）CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</span><br><span class="line"></span><br><span class="line">5.【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。  </span><br><span class="line">&amp;emsp;正例：注意线程安全，使用DateUtils。亦推荐如下处理：</span><br></pre></td></tr></table></figure><pre><code>private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {    @Override    protected DateFormat initialValue() {      return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    }  };  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。  </span><br><span class="line">6.【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。  </span><br><span class="line">&amp;emsp;说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。  </span><br><span class="line">7.【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。  </span><br><span class="line">&amp;emsp;说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。  </span><br><span class="line">8.【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。  </span><br><span class="line">&amp;emsp;说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。  </span><br><span class="line">9.【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。  </span><br><span class="line">10.【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。   </span><br><span class="line">&amp;emsp;说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。   </span><br><span class="line">11.【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。  </span><br><span class="line">&amp;emsp;说明：Random实例包括java.util.Random 的实例或者 Math.random()的方式。  </span><br><span class="line">&amp;emsp;正例：在JDK7之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例。  </span><br><span class="line">12.【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The &quot;Double-Checked Locking is Broken&quot; Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型。  </span><br><span class="line">&amp;emsp;反例：</span><br></pre></td></tr></table></figure><pre><code>class Singleton {  private Helper helper = null;  public Helper getHelper() {    if (helper == null) synchronized(this) {      if (helper == null)      helper = new Helper();    }      return helper;  }  // other methods and fields...}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">13.【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。  </span><br><span class="line">14.【参考】HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。  </span><br><span class="line">15.【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.7 控制语句</span><br><span class="line">1.【强制】在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。  </span><br><span class="line">2.【强制】在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements;   </span><br><span class="line">3.【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成：</span><br></pre></td></tr></table></figure><p>  if (condition) {<br>  …<br>  return obj;<br>  }<br>  // 接着写else的业务逻辑代码;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;说明：如果非得使用if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过3层。  </span><br><span class="line">&amp;emsp;正例：超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：</span><br></pre></td></tr></table></figure></p><p>public void today() {<br>  if (isBusy()) {<br>    System.out.println(“change time.”);<br>    return;<br>  }<br>  if (isFree()) {<br>    System.out.println(“go to travel.”);<br>    retur<br>  }<br>  System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);<br>  return;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.【推荐】除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。    </span><br><span class="line">&amp;emsp;说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？  </span><br><span class="line">&amp;emsp;正例：</span><br></pre></td></tr></table></figure></p><p>// 伪代码如下<br>final boolean existed = (file.open(fileName, “w”) != null) &amp;&amp; (…) || (…);<br>if (existed) {<br>…<br>}<br>反例： if ((file.open(fileName, “w”) != null) &amp;&amp; (…) || (…)) {<br>…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">5.【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。  </span><br><span class="line">6.【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。   </span><br><span class="line">7.【参考】下列情形，需要进行参数校验：  </span><br><span class="line">&amp;emsp;1） 调用频次低的方法。   </span><br><span class="line">&amp;emsp;2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;emsp;3） 需要极高稳定性和可用性的方法。   </span><br><span class="line">&amp;emsp;4） 对外提供的开放接口，不管是RPC/API/HTTP接口。  </span><br><span class="line">&amp;emsp;5） 敏感权限入口。  </span><br><span class="line">8.【参考】下列情形，不需要进行参数校验：   </span><br><span class="line">&amp;emsp;1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。  </span><br><span class="line">&amp;emsp;2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。  </span><br><span class="line">&amp;emsp;3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.8 注释规约</span><br><span class="line">1.【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用/** 内容*/格式，不得使用// xxx方式。   </span><br><span class="line">&amp;emsp;说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。  </span><br><span class="line">2.【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：对子类的实现要求，或者调用注意事项，请一并说明。  </span><br><span class="line">3.【强制】所有的类都必须添加创建者和创建日期。  </span><br><span class="line">4.【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用&apos;/*&apos; &apos;*/&apos;注释，注意与代码对齐。  </span><br><span class="line">5.【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。  </span><br><span class="line">6.【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。  </span><br><span class="line">&amp;emsp;反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。  </span><br><span class="line">7.【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。  </span><br><span class="line">&amp;emsp;说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。  </span><br><span class="line">8.【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。  </span><br><span class="line">&amp;emsp;说明：代码被注释掉有两种可能性：  </span><br><span class="line">&amp;emsp;&amp;emsp;1）后续会恢复此段代码逻辑。  </span><br><span class="line">&amp;emsp;&amp;emsp;2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。  </span><br><span class="line">9.【参考】对于注释的要求：  </span><br><span class="line">&amp;emsp;第一、能够准确反应设计思想和代码逻辑；  </span><br><span class="line">&amp;emsp;第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。  </span><br><span class="line">10.【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。    </span><br><span class="line">反例：</span><br></pre></td></tr></table></figure></p><p>// put elephant into fridge<br>put(elephant, fridge);<br><code>`</code><br>方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。   </p><p>11.【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>&emsp;1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。<br>&emsp;2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。   </p><h2 id="第3章-异常日志"><a href="#第3章-异常日志" class="headerlink" title="第3章    异常日志"></a>第3章    异常日志</h2><h3 id="3-1-异常处理"><a href="#3-1-异常处理" class="headerlink" title="3.1 异常处理"></a>3.1 异常处理</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-编码规范&quot;&gt;&lt;a href=&quot;#Java-编码规范&quot; class=&quot;headerlink&quot; title=&quot;Java 编码规范&quot;&gt;&lt;/a&gt;Java 编码规范&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;编写时间：2018.01.20&lt;br&gt;编写人：Catalp
      
    
    </summary>
    
      <category term="Java" scheme="https://catalpaflat.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://catalpaflat.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CentOS Docker 安装</title>
    <link href="https://catalpaflat.github.io/2018/01/05/docker/%E5%AE%89%E8%A3%85/docker%E5%AE%89%E8%A3%85/"/>
    <id>https://catalpaflat.github.io/2018/01/05/docker/安装/docker安装/</id>
    <published>2018-01-05T08:33:56.000Z</published>
    <updated>2018-03-28T13:29:28.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS-Docker-安装"><a href="#CentOS-Docker-安装" class="headerlink" title="CentOS Docker 安装"></a>CentOS Docker 安装</h1><blockquote><p>Docker支持以下的CentOS版本：</p><ul><li>CentOS 7 (64-bit)</li><li>CentOS 6.5 (64-bit) 或更高的版本</li></ul></blockquote><blockquote><p>前提条件:<br>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。<br>使用 yum 安装（CentOS 7下）</p></blockquote><h2 id="1-检测版本"><a href="#1-检测版本" class="headerlink" title="1. 检测版本"></a>1. 检测版本</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。<br>通过 uname -r 命令查看你当前的内核版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure></p><h2 id="2-安装-Docker"><a href="#2-安装-Docker" class="headerlink" title="2. 安装 Docker"></a>2. 安装 Docker</h2><p>Docker 软件包和依赖包已经包含在默认的 CentOS-Extras 软件源里，安装命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker</span><br></pre></td></tr></table></figure></p><p><img src="http://www.runoob.com/wp-content/uploads/2016/05/docker09.png" alt=""></p><h2 id="3-启动-Docker-后台服务"><a href="#3-启动-Docker-后台服务" class="headerlink" title="3. 启动 Docker 后台服务"></a>3. 启动 Docker 后台服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><p><img src="http://www.runoob.com/wp-content/uploads/2016/05/docker11.png" alt=""></p><h2 id="4-镜像加速"><a href="#4-镜像加速" class="headerlink" title="4.镜像加速"></a>4.镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a><br>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。<br>请在该配置文件中加入（没有该文件的话，请先建一个）：<br>{<br>  “registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]" target="_blank" rel="noopener">http://hub-mirror.c.163.com&quot;]</a><br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CentOS-Docker-安装&quot;&gt;&lt;a href=&quot;#CentOS-Docker-安装&quot; class=&quot;headerlink&quot; title=&quot;CentOS Docker 安装&quot;&gt;&lt;/a&gt;CentOS Docker 安装&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;D
      
    
    </summary>
    
      <category term="docker" scheme="https://catalpaflat.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://catalpaflat.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Java 实现中文-拼音转换</title>
    <link href="https://catalpaflat.github.io/2017/12/16/java/Java%20%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%87-%E6%8B%BC%E9%9F%B3%E8%BD%AC%E6%8D%A2/"/>
    <id>https://catalpaflat.github.io/2017/12/16/java/Java 实现中文-拼音转换/</id>
    <published>2017-12-16T02:16:56.000Z</published>
    <updated>2018-03-28T12:55:25.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-实现中文-拼音转换"><a href="#Java-实现中文-拼音转换" class="headerlink" title="Java 实现中文-拼音转换"></a>Java 实现中文-拼音转换</h1><pre><code>/** * 中文转拼音 * * @author ： CatalpaFlat */public class ChineseToPinyinUtil {    /**     * 将文字转为汉语拼音     *     * @param chineseLanguage 要转成拼音的中文     */    public static String toHanyuPinyin(String chineseLanguage) {        char[] clChars = chineseLanguage.trim().toCharArray();        StringBuilder hanyupinyin = new StringBuilder();        HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();        // 输出拼音全部小写        defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);        // 不带声调        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);        defaultFormat.setVCharType(HanyuPinyinVCharType.WITH_V);        try {            for (char clChar : clChars) {                // 如果字符是中文,则将中文转为汉语拼音                if (String.valueOf(clChar).matches(&quot;[\u4e00-\u9fa5]+&quot;)) {                    hanyupinyin.append(PinyinHelper.toHanyuPinyinStringArray(clChar, defaultFormat)[0]);                    // 如果字符不是中文,则不转换                } else {                    hanyupinyin.append(clChar);                }            }        } catch (BadHanyuPinyinOutputFormatCombination e) {            System.out.println(&quot;字符不能转成汉语拼音&quot;);        }        return hanyupinyin.toString();    }    public static String getFirstLettersUp(String chineseLanguage) {        return getFirstLetters(chineseLanguage, HanyuPinyinCaseType.UPPERCASE);    }    public static String getFirstLettersLo(String chineseLanguage) {        return getFirstLetters(chineseLanguage, HanyuPinyinCaseType.LOWERCASE);    }    private static String getFirstLetters(String chineseLanguage, HanyuPinyinCaseType caseType) {        char[] clChars = chineseLanguage.trim().toCharArray();        StringBuilder hanyupinyin = new StringBuilder();        HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();        // 输出拼音全部大写        defaultFormat.setCaseType(caseType);        // 不带声调        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);        try {            for (char clChar : clChars) {                String str = String.valueOf(clChar);                // 如果字符是中文,则将中文转为汉语拼音,并取第一个字母                if (str.matches(&quot;[\u4e00-\u9fa5]+&quot;)) {                    hanyupinyin.append(PinyinHelper.toHanyuPinyinStringArray(clChar, defaultFormat)[0].substring(0, 1));                    // 如果字符是数字,取数字                } else if (str.matches(&quot;[0-9]+&quot;)) {                    hanyupinyin.append(clChar);                    // 如果字符是字母,取字母                } else if (str.matches(&quot;[a-zA-Z]+&quot;)) {                    hanyupinyin.append(clChar);                    //如果是标点符号的话，带着                } else {// 否则不转换                    hanyupinyin.append(clChar);                }            }        } catch (BadHanyuPinyinOutputFormatCombination e) {            System.out.println(&quot;字符不能转成汉语拼音&quot;);        }        return hanyupinyin.toString();    }    public static String getPinyinString(String chineseLanguage) {        char[] clChars = chineseLanguage.trim().toCharArray();        StringBuilder hanyupinyin = new StringBuilder();        HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();        // 输出拼音全部大写        defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);        // 不带声调        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);        try {            for (char clChar : clChars) {                String str = String.valueOf(clChar);                // 如果字符是中文,则将中文转为汉语拼音,并取第一个字母                if (str.matches(&quot;[\u4e00-\u9fa5]+&quot;)) {                    hanyupinyin.append(PinyinHelper.toHanyuPinyinStringArray(                            clChar, defaultFormat)[0]);                    // 如果字符是数字,取数字                } else if (str.matches(&quot;[0-9]+&quot;)) {                    // 如果字符是字母,取字母                    hanyupinyin.append(clChar);                } else if (str.matches(&quot;[a-zA-Z]+&quot;)) {                    hanyupinyin.append(clChar);                }            }        } catch (BadHanyuPinyinOutputFormatCombination e) {            System.out.println(&quot;字符不能转成汉语拼音&quot;);        }        return hanyupinyin.toString();    }    /**     * 取第一个汉字的第一个字符     */    public static String getFirstLetter(String chineseLanguage) {        char[] clChars = chineseLanguage.trim().toCharArray();        String hanyupinyin = &quot;&quot;;        HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();        // 输出拼音全部大写        defaultFormat.setCaseType(HanyuPinyinCaseType.UPPERCASE);        // 不带声调        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);        try {            String str = String.valueOf(clChars[0]);            // 如果字符是中文,则将中文转为汉语拼音,并取第一个字母            if (str.matches(&quot;[\u4e00-\u9fa5]+&quot;)) {                hanyupinyin = PinyinHelper.toHanyuPinyinStringArray(                        clChars[0], defaultFormat)[0].substring(0, 1);                // 如果字符是数字,取数字            } else if (str.matches(&quot;[0-9]+&quot;)) {                hanyupinyin += clChars[0];                // 如果字符是字母,取字母            } else if (str.matches(&quot;[a-zA-Z]+&quot;)) {                hanyupinyin += clChars[0];            }        } catch (BadHanyuPinyinOutputFormatCombination e) {            System.out.println(&quot;字符不能转成汉语拼音&quot;);        }        return hanyupinyin;    }//    public static void main(String[] args) {//        ChineseToPinyinUtil hanyuPinyinHelper = new ChineseToPinyinUtil();//        String city = ChineseToPinyinUtil.toHanyuPinyin(&quot;深圳市&quot;);//        String string = &quot;shenzhen&quot;;//        if (city.contains(string)) {//            System.out.println(&quot;OK&quot;);//        }//    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-实现中文-拼音转换&quot;&gt;&lt;a href=&quot;#Java-实现中文-拼音转换&quot; class=&quot;headerlink&quot; title=&quot;Java 实现中文-拼音转换&quot;&gt;&lt;/a&gt;Java 实现中文-拼音转换&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;/**
 * 中文转拼音
 
      
    
    </summary>
    
      <category term="Java" scheme="https://catalpaflat.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://catalpaflat.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>自定义Quartz超实用工具类</title>
    <link href="https://catalpaflat.github.io/2017/11/17/Quartz/%E8%87%AA%E5%AE%9A%E4%B9%89Quartz%E8%B6%85%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://catalpaflat.github.io/2017/11/17/Quartz/自定义Quartz超实用工具类/</id>
    <published>2017-11-17T03:09:37.000Z</published>
    <updated>2018-03-28T13:18:51.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义Quartz超实用工具类"><a href="#自定义Quartz超实用工具类" class="headerlink" title="自定义Quartz超实用工具类"></a>自定义Quartz超实用工具类</h1><h2 id="1-添加maven依赖"><a href="#1-添加maven依赖" class="headerlink" title="1.添加maven依赖"></a>1.添加maven依赖</h2><pre><code> &lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;  &lt;artifactId&gt;quartz&lt;/artifactId&gt;  &lt;version&gt;${quartz.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="2-实现Quartz实用工具类"><a href="#2-实现Quartz实用工具类" class="headerlink" title="2.实现Quartz实用工具类"></a>2.实现Quartz实用工具类</h2><pre><code>/** * Quartz任务调度器工具类 * * @author CatalpaFlat * @date Create in 10:25 2017/11/16 */public class QuartzUtil {    /**     * 调度器工厂     */    private static SchedulerFactory schedulerFactory = new StdSchedulerFactory();    /**     * 默认Job组名     */    private static String JOB_GROUP_NAME = &quot;DEFAULT_JOB_GROUP_NAME&quot;;    /**     * 默认触发器组名     */    private static String TRIGGER_GROUP_NAME = &quot;DEFAULT_TRIGGER_GROUP_NAME&quot;;    /**     * 获取调度器     *     * @return Scheduler     * @throws SchedulerException Scheduler获取异常     */    private static Scheduler getScheduler() throws SchedulerException {        return schedulerFactory.getScheduler();    }    /**     * 获取CronTrigger     *     * @param jobName          任务名     * @param triggerGroupName 触发器组名（为空使用默认）     * @param time             crond格式时间     * @return CronTrigger     */    private static CronTrigger getCronTrigger(String jobName, String triggerGroupName, String time) {        if (StringUtils.isBlank(triggerGroupName)) {            triggerGroupName = TRIGGER_GROUP_NAME;        }        return TriggerBuilder.newTrigger().withIdentity(jobName, triggerGroupName)                .withSchedule(CronScheduleBuilder.cronSchedule(time)).build();    }    /**     * 获取JobDetail     *     * @param jobName      任务名     * @param jobGroupName 任务组名（为空使用默认）     * @param cls          任务类     * @param jobDataMap   附带参数     * @return JobDetail     */    private static JobDetail getJobDetail(String jobName, String jobGroupName, Class&lt;? extends Job&gt; cls, JobDataMap jobDataMap) {        if (StringUtils.isBlank(jobGroupName)) {            jobGroupName = JOB_GROUP_NAME;        }        if (jobDataMap != null) {            return JobBuilder.newJob(cls).withIdentity(jobName, jobGroupName).usingJobData(jobDataMap).build();        } else {            return JobBuilder.newJob(cls).withIdentity(jobName, jobGroupName).build();        }    }    /**     * 设置JobDetail 和 CronTrigger 到 scheduler（已获取的调度器中，无需重复调用）     *     * @param cls              任务嘞     * @param jobName          任务名     * @param jobGroupName     任务组名（为空使用默认）     * @param triggerGroupName 触发器组名（为空使用默认）     * @param time             crond格式时间     * @param jobDataMap       附带参数     * @param scheduler        调度器     * @return 设置成功与否     * @throws SchedulerException 调度器异常     */    private static boolean setJobDetailAndCronTriggerInScheduler(Class&lt;? extends Job&gt; cls, String jobName, String jobGroupName, String triggerGroupName,                                                                 String time, JobDataMap jobDataMap, Scheduler scheduler) throws SchedulerException {        if (!isJobKey(scheduler, jobName, jobGroupName)) {            return false;        }        JobDetail jobDetail = getJobDetail(jobName, jobGroupName, cls, jobDataMap);        CronTrigger trigger = getCronTrigger(jobName, triggerGroupName, time);        scheduler.scheduleJob(jobDetail, trigger);        if (!scheduler.isShutdown()) {            scheduler.start();        }        return true;    }    /**     * 从调度器中移除Job     *     * @param scheduler  调度器     * @param triggerKey 触发器key（名，组）     * @param jobKey     任务key（名，组）     */    private static void removeJob(Scheduler scheduler, TriggerKey triggerKey, JobKey jobKey) {        try {            // 停止触发器            scheduler.pauseTrigger(triggerKey);            //移除触发器            scheduler.unscheduleJob(triggerKey);            // 删除任务            scheduler.deleteJob(jobKey);        } catch (SchedulerException e) {            e.printStackTrace();        }    }    /**     * 使用CronTrigger类型添加任务     *     * @param scheduler        调度器     * @param cls              任务嘞     * @param jobName          任务名     * @param jobGroupName     任务组名（为空使用默认）     * @param triggerGroupName 触发器组名（为空使用默认）     * @param time             crond格式时间     * @param jobDataMap       附带参数     * @return 是否添加成功     */    private static boolean addJobByCronTrigger(Scheduler scheduler, Class&lt;? extends Job&gt; cls, String jobName, String jobGroupName,                                               String triggerGroupName, String time, JobDataMap jobDataMap) {        try {            return setJobDetailAndCronTriggerInScheduler(cls, jobName, jobGroupName, triggerGroupName, time, jobDataMap, scheduler);        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }    /**     * 判断是否存在JobKey     *     * @param scheduler    任务调度器     * @param jobName      任务名     * @param jobGroupName 任务组名     * @return 是否存在JobKey     */    private static boolean isJobKey(Scheduler scheduler, String jobName, String jobGroupName) {        JobKey jobKey = JobKey.jobKey(jobName, jobGroupName);        try {            JobDetail jobDetail = scheduler.getJobDetail(jobKey);            return jobDetail == null;        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }    /**     * 添加定时任务     *     * @param cls              任务类     * @param jobName          任务名     * @param jobGroupName     任务组名（为空使用默认）     * @param triggerGroupName 触发器组名（为空使用默认）     * @param time             crond格式时间     * @param jobDataMap       附带参数     * @return 是否正常添加任务     */    public static boolean addJobByCronTrigger(Class&lt;? extends Job&gt; cls, String jobName, String jobGroupName,                                              String triggerGroupName, String time, JobDataMap jobDataMap) {        try {            if (StringUtils.isBlank(jobName)) {                return false;            }            Scheduler scheduler = getScheduler();            return setJobDetailAndCronTriggerInScheduler(cls, jobName, jobGroupName, triggerGroupName, time, jobDataMap, scheduler);        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }    /**     * 修改任务时间     *     * @param jobName          任务名     * @param time             crond格式时间     * @param jobGroupName     任务组名（为空使用默认）     * @param triggerGroupName 触发器组名（为空使用默认）     * @param jobDataMap       附带参数     * @return 是否修改成功     */    public static boolean modifyJobTime(String jobName, String time, String jobGroupName,                                        String triggerGroupName, JobDataMap jobDataMap) {        try {            if (StringUtils.isBlank(jobName)) {                return false;            }            Scheduler scheduler = getScheduler();            if (StringUtils.isBlank(triggerGroupName)) {                triggerGroupName = TRIGGER_GROUP_NAME;            }            TriggerKey triggerKey = TriggerKey.triggerKey(jobName, triggerGroupName);            CronTrigger trigger = (CronTrigger) scheduler.getTrigger(triggerKey);            if (trigger == null) {                return false;            }            String oldTime = trigger.getCronExpression();            if (!oldTime.equalsIgnoreCase(time)) {                if (StringUtils.isBlank(jobGroupName)) {                    jobGroupName = JOB_GROUP_NAME;                }                JobKey jobKey = JobKey.jobKey(jobName, jobGroupName);                JobDetail jobDetail = scheduler.getJobDetail(jobKey);                Class&lt;? extends Job&gt; jobClass = jobDetail.getJobClass();                removeJob(scheduler, triggerKey, jobKey);                return addJobByCronTrigger(scheduler, jobClass, jobName, jobGroupName, triggerGroupName, time, jobDataMap);            }            return true;        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }    /**     * 启动所有定时任务     */    public static void startJobs() {        try {            Scheduler scheduler = getScheduler();            scheduler.start();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    /**     * 关闭所有定时任务     */    public static void shutdownJobs() {        try {            Scheduler scheduler = getScheduler();            if (!scheduler.isShutdown()) {                scheduler.shutdown();            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    /**     * 停止一个job任务     *     * @param jobName      任务名     * @param jobGroupName 任务组名（空位默认）     * @return 是否停止     */    public static boolean pauseJob(String jobName, String jobGroupName) {        try {            Scheduler scheduler = getScheduler();            if (StringUtils.isBlank(jobGroupName)) {                jobGroupName = JOB_GROUP_NAME;            }            scheduler.interrupt(JobKey.jobKey(jobName, jobGroupName));            return true;        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }    /**     * 恢复一个job任务     *     * @param jobName      任务名     * @param jobGroupName 任务组名（空位默认）     * @return 是否恢复     */    public static boolean resumeJob(String jobName, String jobGroupName) {        try {            Scheduler scheduler = getScheduler();            scheduler.resumeJob(JobKey.jobKey(jobName, jobGroupName));            return true;        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }    /**     * 添加定时任务     *     * @param cls  任务类     * @param bJob 任务类属性     * @return 是否添加成功     */    public static boolean addJobByCronTrigger(Class&lt;? extends Job&gt; cls, BaseJob bJob) {        if (bJob == null) {            return false;        }        String jobName = bJob.getJobName();        if (StringUtils.isBlank(jobName)) {            return false;        }        try {            Scheduler scheduler = getScheduler();            return setJobDetailAndCronTriggerInScheduler(cls, jobName, bJob.getJobGroupName(), bJob.getTriggerGroupName(), bJob.getCronTime(), bJob.getJobDataMap(), scheduler);        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }    /**     * 修改任务JobDateMap     *     * @param cls  任务类     * @param bJob 任务类属性     * @return 是否修改成功     */    public static boolean modifyJobDateMap(Class&lt;? extends Job&gt; cls, BaseJob bJob) {        if (bJob == null) {            return false;        }        String jobName = bJob.getJobName();        if (StringUtils.isBlank(jobName)) {            return false;        }        String triggerGroupName = bJob.getTriggerGroupName();        if (StringUtils.isBlank(triggerGroupName)) {            triggerGroupName = TRIGGER_GROUP_NAME;        }        TriggerKey triggerKey = TriggerKey.triggerKey(jobName, triggerGroupName);        String jobGroupName = bJob.getJobGroupName();        if (StringUtils.isBlank(jobGroupName)) {            jobGroupName = JOB_GROUP_NAME;        }        try {            Scheduler scheduler = getScheduler();            JobKey jobKey = JobKey.jobKey(jobName, jobGroupName);            JobDetail jobDetail1 = scheduler.getJobDetail(jobKey);            if (jobDetail1 == null) {                return false;            }            JobDataMap oldJobDataMap = jobDetail1.getJobDataMap();            JobDataMap jobDataMap = bJob.getJobDataMap();            if (!oldJobDataMap.equals(jobDataMap)) {                Class&lt;? extends Job&gt; jobClass = jobDetail1.getJobClass();                removeJob(scheduler, triggerKey, jobKey);                return addJobByCronTrigger(scheduler, jobClass, jobName, jobGroupName, triggerGroupName, bJob.getCronTime(), jobDataMap);            }            return true;        } catch (SchedulerException e) {            e.printStackTrace();            return false;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义Quartz超实用工具类&quot;&gt;&lt;a href=&quot;#自定义Quartz超实用工具类&quot; class=&quot;headerlink&quot; title=&quot;自定义Quartz超实用工具类&quot;&gt;&lt;/a&gt;自定义Quartz超实用工具类&lt;/h1&gt;&lt;h2 id=&quot;1-添加maven依赖&quot;&gt;
      
    
    </summary>
    
      <category term="Quartz" scheme="https://catalpaflat.github.io/categories/Quartz/"/>
    
    
      <category term="Quartz" scheme="https://catalpaflat.github.io/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>深入解读Quartz任务调度器</title>
    <link href="https://catalpaflat.github.io/2017/11/15/Quartz/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBQuartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>https://catalpaflat.github.io/2017/11/15/Quartz/深入解读Quartz任务调度器/</id>
    <published>2017-11-15T09:24:17.000Z</published>
    <updated>2018-03-28T13:18:13.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入解读Quartz任务调度器"><a href="#深入解读Quartz任务调度器" class="headerlink" title="深入解读Quartz任务调度器"></a>深入解读Quartz任务调度器</h1><h2 id="1-Quartz简介"><a href="#1-Quartz简介" class="headerlink" title="1.Quartz简介"></a>1.Quartz简介</h2><h3 id="1-1-概要"><a href="#1-1-概要" class="headerlink" title="1.1.概要"></a>1.1.概要</h3><p>　　Quartz是OpenSymphony提供的强大的开源任务调度框架。　　<br>　　官网：<a href="http://www.quartz-scheduler.org" target="_blank" rel="noopener">http://www.quartz-scheduler.org</a><br>　　纯Java实现，精细控制排程。<br><img src="https://i.imgur.com/MB8dnAN.png" alt=""></p><h3 id="1-2-Quartz特点"><a href="#1-2-Quartz特点" class="headerlink" title="1.2.Quartz特点"></a>1.2.Quartz特点</h3><ol><li>强大的调度能力</li><li>灵活的应用方式</li><li>强大的分布式和集群能力<h3 id="1-3-Quartz设计模式"><a href="#1-3-Quartz设计模式" class="headerlink" title="1.3.Quartz设计模式"></a>1.3.Quartz设计模式</h3></li></ol><ul><li>Builder模式</li><li>组件模式</li><li>Factory模式</li><li>链式写法<h3 id="1-4-Quartz体系结构"><a href="#1-4-Quartz体系结构" class="headerlink" title="1.4.Quartz体系结构"></a>1.4.Quartz体系结构</h3><h4 id="1-4-1-三大核心"><a href="#1-4-1-三大核心" class="headerlink" title="1.4.1.三大核心"></a>1.4.1.三大核心</h4></li><li>调度器</li><li>任务</li><li>触发器 </li></ul><p><img src="https://i.imgur.com/mAHuNjM.jpg" alt=""></p><h4 id="1-4-2-重要组成"><a href="#1-4-2-重要组成" class="headerlink" title="1.4.2.重要组成"></a>1.4.2.重要组成</h4><p>1）任务： </p><ul><li><p>Job：表示一个工作，要执行的具体内容。此接口中只有一个方法。要创建一个任务，必须得实现这个接口。该接口只有一个execute方法，任务每次被调用的时候都会执行这个execute方法的逻辑，类似TimerTask的run方法，在里面编写业务逻辑。 </p><pre><code>public class TestJob implements Job {    /**把要执行的操作，写在execute方法中  */    @Override    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);        System.out.println(&quot;I can do something...&quot;);        System.out.println(sdf.format(new Date()));    }}</code></pre></li></ul><p>生命周期：在每次调度器执行job时，它在调用execute方法前会创建一个新的job实例，当调用完成之后，关联的job对象实例会被释放，释放的实例会被垃圾回收机制回收。</p><ul><li><p>JobBuilder：可向任务传递数据,通常情况下,我们使用它就可向任务类发送数据了，如有特别复杂的传递参数,它提供了一个传递递:JobDataMap对象的方法　　</p><pre><code>JobDetail jobDetail =  JobBuilder.newJob(TestJob.class).withIdentity(&quot;testJob&quot;,&quot;group1&quot;).build();</code></pre></li><li><p>JobDetail：用来保存我们任务的详细信息。一个JobDetail可以有多个Trigger，但是一个Trigger只能对应一个JobDetail。下面是JobDetail的一些常用的属性和含义：　　</p></li></ul><p>　　<img src="https://i.imgur.com/aid7mV3.png" alt=""></p><ul><li><p>JobStore：负责跟踪所有你给scheduler的“工作数据”：jobs, triggers, calendars, 等。</p><ul><li><p>RAMJobStore：是使用最简单的也是最高效(依据CPU时间)的JobStore 。RAMJobStore 正如它名字描述的一样，它保存数据在RAM。缺点是你的应用结束之后所有的数据也丢失了–这意味着RAMJobStore 不具有保持job和trigger持久的能力。对于一些程序是可以接受的，甚至是期望的，但对于其他的程序可能是灾难性的。使用RAMJobStore配置Quartz：配置如下</p><pre><code>org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore </code></pre></li><li><p>JDBCJobStore：以JDBC的方式保存数据在数据库中。它比RAMJobStore的配置复杂一点，也没有RAMJobStore快。然而,性能缺点不是糟透了,特别是如果你在数据库表主键上建立了索引。在机器之间的LAN(在scheduler 和数据库之间)合理的情况下，检索和更新一个被触发的Trigger花费的时间少于10毫秒。几乎适用于所有的数据库，广泛用于 Oracle。PostgreSQL, MySQL, MS SQLServer, HSQLDB, 和DB2。使用JDBCJobStore之前你必须首先创建一系列Quartz要使用的表。你可以发现表创建语句在Quartz发布目录的 “docs/dbTables”下面。你需要确定你的应用要使用的事务类型。如果你不想绑定调度命令(例如增加和移除Trigger)到其他的事务，你可以使用JobStoreTX (最常用的选择)作为你的Jobstore。如果你需要Quartz和其他的事务(例如在J2EE应用服务器中)一起工作，你应该使用JobStoreCMT ，Quartz 将让应用服务器容器管理这个事务。使用JobStoreTx配置Quartz：</p><pre><code>org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX  org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate  #配置表的前缀  org.quartz.jobStore.tablePrefix = QRTZ_  #使用JNDI数据源的时候，数据源的名字  org.quartz.jobStore.dataSource = myDS      </code></pre></li><li><p>TerracottaJobStore：提供了一个方法：在不使用数据库的情况下使它具有收缩性和强壮性。可以是集群的也可以是非集群的，在这两种情况下为你的job数据提供了一个存储机制用于应用程序重启之间持久,因为数据是存储在Terracotta服务器。它的性能比使用数据库访问JDBCJobStore好一点儿(大约是一个数量级)，但是明显比RAMJobStore慢。使用TerracottaJobStore配置Quartz：</p><pre><code>org.quartz.jobStore.class = org.terracotta.quartz.TerracottaJobStore  org.quartz.jobStore.tcConfigUrl = localhost:9510  </code></pre></li></ul></li><li><p>JobDataMap：中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据；JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。</p><ul><li><p>存：</p><pre><code>JobDetail jobDetail =  JobBuilder.newJob(TestJob.class).withIdentity(&quot;testJob&quot;,&quot;group1&quot;).usingJobData(&quot;date1&quot;,&quot;存内容&quot;).build(); </code></pre></li><li><p>取：</p><pre><code>public class TestJob implements Job {    /**把要执行的操作，写在execute方法中  */    @Override    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {        JobKey key = jobExecutionContext.getJobDetail().getKey();        JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap();        String date1 = jobDataMap.getString(&quot;date1&quot;);    }}</code></pre></li></ul></li></ul><hr><p>2）触发器：用来触发执行Job<br><img src="https://i.imgur.com/Bg3Bxud.png" alt="">  </p><p>2.1）触发器通用属性： </p><ul><li>Jobkey：表示job实例的标识，触发器被触发时，该指定的job实例会被执行</li><li>StartTime：表示触发器的时间表首次被触发的时间，它的值类型为：java.util.Date</li><li>EndTime：指定触发器的不再被触发的时间，它的值类型为：java.util.Date</li></ul><p>2.2）触发器类型：</p><ul><li><p>SimpleTrigger： 主要是针对一些相对简单的时间触发进行配置使用，比如在指定的时间开始然后在一定的时间间隔之内重复执行一个Job，同时可以任意指定重复的次数。下面就是使用一个SimpleTrigger的例子:  </p><pre><code>//创建触发器 每3秒钟执行一次(无开始时间和结束时间)Trigger trigger = TriggerBuilder.newTrigger()            .withIdentity(&quot;trigger1&quot;, &quot;group3&quot;)            .withSchedule(            SimpleScheduleBuilder.simpleSchedule()            .withIntervalInSeconds(3).repeatForever()).build();//创建触发器 每3秒钟执行一次(有开始时间和结束时间) long now = new Date().getTime();Date start = new Date(now+6000);Date end = new Date(now+12000);//创建触发器 每3秒钟执行一次Trigger trigger = TriggerBuilder.newTrigger()                  .withIdentity(&quot;trigger1&quot;, &quot;group3&quot;)                  .startAt(start)                  .endAt(end)                  .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(3).repeatForever()).build();</code></pre><p>SimpleTrigger具有丰富的构造函数，根据业务需求构造不同的构造函数。</p></li><li><p>CronTrigger： 可以配置更复杂的触发时刻表，基于日历的作业触发器，而不像SimpleTrigger那样精确指定间隔时间，比SimpleTrigger更加常用。  </p></li></ul><p>　　Cron表达式：用于配置CronTrigger实例，是由7个表达式组成的字符串，描述了时间表的详细信息。<br>　　格式为：[秒][分][时][日][月][周][年]<br>　　Cron表达式特殊字符意义对应表：<br>　　<img src="https://i.imgur.com/spUTIoo.png" alt=""><br>　　通配符说明：<br>　　<img src="https://i.imgur.com/lkq9yso.png" alt=""><br>　　Cron表达式例子：<br>　　<img src="https://i.imgur.com/SOh7Ujr.png" alt=""></p><pre><code>TriggerBuilder.newTrigger().withIdentity(&quot;trigger2&quot;,&quot;group2&quot;)            .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0 0 9 ? * 6L *&quot;)).build();</code></pre><p>　　Cron表达式小技巧：<br>　　1. ‘L’和‘W’可以一起组合使用<br>　　2. 周字段英文字母不区分大小写即MOM与mom相同<br>　　3. 利用工具，在线生成cron表达式：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a>  </p><ul><li><p>NthIncludedDayTrigger：是 Quartz 开发团队最新加入到框架中的一个 Trigger。它设计用于在每一间隔类型的第几天执行 Job。例如，你要在每个月的 15 号执行开票的 Job，用 NthIncludedDayTrigger就再合适不过了。</p><pre><code>NthIncludedDayTrigger trigger = new NthIncludedDayTrigger(&quot;NthIncludedDayTrigger&quot;,Scheduler.DEFAULT_GROUP);            trigger.setN(15);            trigger.setIntervalType(NthIncludedDayTrigger.INTERVAL_TYPE_MONTHLY);</code></pre></li></ul><hr><p>3）调度器Scheduler<br>　　代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。<br>　　Scheduler可以将Trigger绑定到某一JobDetail中，这样当Trigger触发时，对应的Job就被执行。一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job。<br>　　可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例；  </p><pre><code>SchedulerFactory schedulerfactory=new StdSchedulerFactory();Scheduler scheduler = schedulerfactory.getScheduler(); DirectSchedulerFactory factory = DirectSchedulerFactory.getInstance();try {    Scheduler scheduler = factory.getScheduler();} catch (SchedulerException e) {    e.printStackTrace();}</code></pre><hr><p>4)SchedulerFactory:  </p><ul><li>使用一组参数（java.util.Properties）来创建和出书啊Quartz调度器</li><li>配置参数一般存储在quartz.properties中</li><li>调用getScheduler方法就能创建和初始化调度器</li></ul><hr><p>5)quartz.properties:<br>Quartz-Job的quartz.properties配置文件说明，此文件在quartz的jar包有，可直接拿过来使用不过只有基本的几个配置 自己可根据需要进行扩充；另外如果项目中没有对该配置文件重写，则Quartz会加载自己jar包中的quartz.properties文件。  </p><pre><code># Default Properties file for use by StdSchedulerFactory  # to create a Quartz Scheduler Instance, if a different  # properties file is not explicitly specified.  #  # ===========================================================================  # Configure Main Scheduler Properties 调度器属性  # ===========================================================================  org.quartz.scheduler.instanceName: DefaultQuartzScheduler  #org.quartz.scheduler.instanceid:AUTO  org.quartz.scheduler.rmi.export: false  org.quartz.scheduler.rmi.proxy: false  org.quartz.scheduler.wrapJobExecutionInUserTransaction: false  # ===========================================================================    # Configure ThreadPool 线程池属性    # ===========================================================================  #线程池的实现类（一般使用SimpleThreadPool即可满足几乎所有用户的需求）  org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool  #指定线程数，至少为1（无默认值）(一般设置为1-100直接的整数合适)  org.quartz.threadPool.threadCount: 10  #设置线程的优先级（最大为java.lang.Thread.MAX_PRIORITY 10，最小为Thread.MIN_PRIORITY 1，默认为5）  org.quartz.threadPool.threadPriority: 5  #设置SimpleThreadPool的一些属性  #设置是否为守护线程  #org.quartz.threadpool.makethreadsdaemons = false  #org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true  #org.quartz.threadpool.threadsinheritgroupofinitializingthread=false  #线程前缀默认值是：[Scheduler Name]_Worker  #org.quartz.threadpool.threadnameprefix=swhJobThead;  # 配置全局监听(TriggerListener,JobListener) 则应用程序可以接收和执行 预定的事件通知  # ===========================================================================  # Configuring a Global TriggerListener 配置全局的Trigger监听器  # MyTriggerListenerClass 类必须有一个无参数的构造函数，和 属性的set方法，目前2.2.x只支持原始数据类型的值（包括字符串）  # ===========================================================================  #org.quartz.triggerListener.NAME.class = com.swh.MyTriggerListenerClass  #org.quartz.triggerListener.NAME.propName = propValue  #org.quartz.triggerListener.NAME.prop2Name = prop2Value  # ===========================================================================  # Configuring a Global JobListener 配置全局的Job监听器  # MyJobListenerClass 类必须有一个无参数的构造函数，和 属性的set方法，目前2.2.x只支持原始数据类型的值（包括字符串）  # ===========================================================================  #org.quartz.jobListener.NAME.class = com.swh.MyJobListenerClass  #org.quartz.jobListener.NAME.propName = propValue  #org.quartz.jobListener.NAME.prop2Name = prop2Value  # ===========================================================================    # Configure JobStore 存储调度信息（工作，触发器和日历等）  # ===========================================================================  # 信息保存时间 默认值60秒  org.quartz.jobStore.misfireThreshold: 60000  #保存job和Trigger的状态信息到内存中的类  org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore  # ===========================================================================    # Configure SchedulerPlugins 插件属性 配置  # ===========================================================================  # 自定义插件    #org.quartz.plugin.NAME.class = com.swh.MyPluginClass  #org.quartz.plugin.NAME.propName = propValue  #org.quartz.plugin.NAME.prop2Name = prop2Value  #配置trigger执行历史日志（可以看到类的文档和参数列表）  org.quartz.plugin.triggHistory.class = org.quartz.plugins.history.LoggingTriggerHistoryPlugin    org.quartz.plugin.triggHistory.triggerFiredMessage = Trigger {1}.{0} fired job {6}.{5} at: {4, date, HH:mm:ss MM/dd/yyyy}    org.quartz.plugin.triggHistory.triggerCompleteMessage = Trigger {1}.{0} completed firing job {6}.{5} at {4, date, HH:mm:ss MM/dd/yyyy} with resulting trigger instruction code: {9}    #配置job调度插件  quartz_jobs(jobs and triggers内容)的XML文档    #加载 Job 和 Trigger 信息的类   （1.8之前用：org.quartz.plugins.xml.JobInitializationPlugin）  org.quartz.plugin.jobInitializer.class = org.quartz.plugins.xml.XMLSchedulingDataProcessorPlugin  #指定存放调度器(Job 和 Trigger)信息的xml文件，默认是classpath下quartz_jobs.xml  org.quartz.plugin.jobInitializer.fileNames = my_quartz_job2.xml    #org.quartz.plugin.jobInitializer.overWriteExistingJobs = false    org.quartz.plugin.jobInitializer.failOnFileNotFound = true    #自动扫描任务单并发现改动的时间间隔,单位为秒  org.quartz.plugin.jobInitializer.scanInterval = 10  #覆盖任务调度器中同名的jobDetail,避免只修改了CronExpression所造成的不能重新生效情况  org.quartz.plugin.jobInitializer.wrapInUserTransaction = false  # ===========================================================================    # Sample configuration of ShutdownHookPlugin  ShutdownHookPlugin插件的配置样例  # ===========================================================================  #org.quartz.plugin.shutdownhook.class = \org.quartz.plugins.management.ShutdownHookPlugin  #org.quartz.plugin.shutdownhook.cleanShutdown = true  #  # Configure RMI Settings 远程服务调用配置  #  #如果你想quartz-scheduler出口本身通过RMI作为服务器，然后设置“出口”标志true(默认值为false)。  #org.quartz.scheduler.rmi.export = false  #主机上rmi注册表(默认值localhost)  #org.quartz.scheduler.rmi.registryhost = localhost  #注册监听端口号（默认值1099）  #org.quartz.scheduler.rmi.registryport = 1099  #创建rmi注册，false/never：如果你已经有一个在运行或不想进行创建注册  # true/as_needed:第一次尝试使用现有的注册，然后再回来进行创建  # always:先进行创建一个注册，然后再使用回来使用注册  #org.quartz.scheduler.rmi.createregistry = never  #Quartz Scheduler服务端端口，默认是随机分配RMI注册表  #org.quartz.scheduler.rmi.serverport = 1098  #true:链接远程服务调度(客户端),这个也要指定registryhost和registryport，默认为false  # 如果export和proxy同时指定为true，则export的设置将被忽略  #org.quartz.scheduler.rmi.proxy = false  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入解读Quartz任务调度器&quot;&gt;&lt;a href=&quot;#深入解读Quartz任务调度器&quot; class=&quot;headerlink&quot; title=&quot;深入解读Quartz任务调度器&quot;&gt;&lt;/a&gt;深入解读Quartz任务调度器&lt;/h1&gt;&lt;h2 id=&quot;1-Quartz简介&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Quartz" scheme="https://catalpaflat.github.io/categories/Quartz/"/>
    
    
      <category term="Quartz" scheme="https://catalpaflat.github.io/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>消息队列之RabbitMQ</title>
    <link href="https://catalpaflat.github.io/2017/11/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/"/>
    <id>https://catalpaflat.github.io/2017/11/11/消息队列/RabbitMQ/</id>
    <published>2017-11-11T08:08:34.000Z</published>
    <updated>2018-03-28T13:04:44.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="1-RabbitMQ概述"><a href="#1-RabbitMQ概述" class="headerlink" title="1.RabbitMQ概述"></a>1.RabbitMQ概述</h3><p>&emsp;&emsp;MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ等等。</p><h3 id="2-RabbitMQ安装"><a href="#2-RabbitMQ安装" class="headerlink" title="2.RabbitMQ安装"></a>2.RabbitMQ安装</h3><p>Windows环境下：<br>RabbitMQ基于erlang，因此先安装erlang<br>2.1 安装erlang<br>2.1.1 下载并安装erlang<br>erlang下载地址：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">http://www.erlang.org/downloads</a><br>erlang安装过程直接一直next到底<br>2.1.2 设置erlang环境变量<br><img src="https://i.imgur.com/IsFZU83.png" alt=""><br>将;%ERLANG_HOME%\bin添加到Path<br>2.1.3 测试erlang是否安装成功<br><img src="https://i.imgur.com/qJAIMRT.png" alt=""><br>2.2 安装RabbitMQ<br>2.2.1 下载并安装RabbitMQ<br>RabbitMQ下载地址：<a href="http://www.rabbitmq.com/install-windows.html" target="_blank" rel="noopener">http://www.rabbitmq.com/install-windows.html</a><br>RabbitMQ安装过程也一直next到底<br>2.2.2 激活 RabbitMQ’s Management Plugin<br>到RabbitMQ的安装目录找到<br>E:\RabbitMQServer\rabbitmq_server-3.6.5\sbin\<br>运行rabbitmq-plugins enable rabbitmq_management<br><img src="https://i.imgur.com/S8Q6YoD.png" alt=""><br>接着直接重启服务<br>rabbitmq-service stop<br><img src="https://i.imgur.com/TgZPpm6.png" alt=""><br>rabbitmq-service start<br><img src="https://i.imgur.com/Qe0CTzI.png" alt=""><br>2.2.3 浏览器访问<a href="http://localhost:15672/#/" target="_blank" rel="noopener">http://localhost:15672/#/</a><br>使用账号：guest密码：guest登录即可<br><img src="https://i.imgur.com/FbJtEqA.png" alt=""><br>自此RabbitMQ安装完毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;h3 id=&quot;1-RabbitMQ概述&quot;&gt;&lt;a href=&quot;#1-RabbitMQ概述&quot; cla
      
    
    </summary>
    
      <category term="消息队列" scheme="https://catalpaflat.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="消息队列" scheme="https://catalpaflat.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java 自定义超实用Redis工具类（满足对象，list，map等类型）</title>
    <link href="https://catalpaflat.github.io/2017/11/11/java/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B6%85%E5%AE%9E%E7%94%A8Redis%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E6%BB%A1%E8%B6%B3%E5%AF%B9%E8%B1%A1%EF%BC%8Clist%EF%BC%8Cmap%E7%AD%89%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>https://catalpaflat.github.io/2017/11/11/java/Java 自定义超实用Redis工具类（满足对象，list，map等类型）/</id>
    <published>2017-11-11T07:11:22.000Z</published>
    <updated>2018-03-28T12:59:07.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义超实用Redis工具类（满足对象，list，map等类型）"><a href="#自定义超实用Redis工具类（满足对象，list，map等类型）" class="headerlink" title="自定义超实用Redis工具类（满足对象，list，map等类型）"></a>自定义超实用Redis工具类（满足对象，list，map等类型）</h1><p>该工具类，可以存储对象、list，map等各种数据类型到Redis中，大大有效提高开发效率。</p><h2 id="1-添加maven依赖"><a href="#1-添加maven依赖" class="headerlink" title="1.添加maven依赖"></a>1.添加maven依赖</h2><pre><code>&lt;!--序列化工具--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.objenesis&lt;/groupId&gt;    &lt;artifactId&gt;objenesis&lt;/artifactId&gt;    &lt;version&gt;${objenesis.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.dyuproject.protostuff/protostuff-core --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;    &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;    &lt;version&gt;${dyuproject.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;    &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;    &lt;version&gt;${dyuproject.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>注：采用序列化工具进行解析。版本如下：</p><pre><code>&lt;dyuproject.version&gt;1.1.3&lt;/dyuproject.version&gt;&lt;objenesis.version&gt;2.6&lt;/objenesis.version&gt;</code></pre><h2 id="2-序列化工具类"><a href="#2-序列化工具类" class="headerlink" title="2.序列化工具类"></a>2.序列化工具类</h2><pre><code>/** * 序列化工具类 * @Author： CatalpaFlat * @Descrition: * @Date: Create in 15:04 2017/11/11 * @Modified BY： */public class ProtoStuffSerializerUtil {    public static &lt;T&gt; byte[] serialize(T obj) {        if (obj == null) {            throw new RuntimeException(&quot;序列化对象(&quot; + obj + &quot;)!&quot;);        }        @SuppressWarnings(&quot;unchecked&quot;)        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) RuntimeSchema.getSchema(obj.getClass());        LinkedBuffer buffer = LinkedBuffer.allocate(1024 * 1024);        byte[] protostuff = null;        try {            protostuff = ProtostuffIOUtil.toByteArray(obj, schema, buffer);        } catch (Exception e) {            throw new RuntimeException(&quot;序列化(&quot; + obj.getClass() + &quot;)对象(&quot; + obj + &quot;)发生异常!&quot;, e);        } finally {            buffer.clear();        }        return protostuff;    }    public static &lt;T&gt; T deserialize(byte[] paramArrayOfByte, Class&lt;T&gt; targetClass) {        if (paramArrayOfByte == null || paramArrayOfByte.length == 0) {            throw new RuntimeException(&quot;反序列化对象发生异常,byte序列为空!&quot;);        }        T instance = null;        try {            // T message = objenesis.newInstance(cls);            instance = targetClass.newInstance();        } catch (InstantiationException | IllegalAccessException e) {            throw new RuntimeException(&quot;反序列化过程中依据类型创建对象失败!&quot;, e);        }        Schema&lt;T&gt; schema = RuntimeSchema.getSchema(targetClass);        ProtostuffIOUtil.mergeFrom(paramArrayOfByte, instance, schema);        return instance;    }    public static &lt;T&gt; byte[] serializeList(List&lt;T&gt; objList) {        if (objList == null || objList.isEmpty()) {            throw new RuntimeException(&quot;序列化对象列表(&quot; + objList + &quot;)参数异常!&quot;);        }        @SuppressWarnings(&quot;unchecked&quot;)        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) RuntimeSchema.getSchema(objList.get(0).getClass());        LinkedBuffer buffer = LinkedBuffer.allocate(1024 * 1024);        byte[] protostuff = null;        ByteArrayOutputStream bos = null;        try {            bos = new ByteArrayOutputStream();            ProtostuffIOUtil.writeListTo(bos, objList, schema, buffer);            protostuff = bos.toByteArray();        } catch (Exception e) {            throw new RuntimeException(&quot;序列化对象列表(&quot; + objList + &quot;)发生异常!&quot;, e);        } finally {            buffer.clear();            try {                if(bos!=null){                    bos.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        return protostuff;    }    public static &lt;T&gt; List&lt;T&gt; deserializeList(byte[] paramArrayOfByte, Class&lt;T&gt; targetClass) {        if (paramArrayOfByte == null || paramArrayOfByte.length == 0) {            throw new RuntimeException(&quot;反序列化对象发生异常,byte序列为空!&quot;);        }        Schema&lt;T&gt; schema = RuntimeSchema.getSchema(targetClass);        List&lt;T&gt; result = null;        try {            result = ProtostuffIOUtil.parseListFrom(new ByteArrayInputStream(paramArrayOfByte), schema);        } catch (IOException e) {            throw new RuntimeException(&quot;反序列化对象列表发生异常!&quot;,e);        }        return result;    }    public static class Person{        int id;        String name;        public Person(){        }        public Person(int id, String name){            this.id = id;            this.name = name;        }        public int getId() {            return id;        }        public String getName() {            return name;        }    }}</code></pre><h2 id="3-配置redisConfig类进行存储"><a href="#3-配置redisConfig类进行存储" class="headerlink" title="3.配置redisConfig类进行存储"></a>3.配置redisConfig类进行存储</h2><pre><code>/** * redis配置类 * @Author： CatalpaFlat * @Descrition: * @Date: Create in 15:04 2017/11/11 * @Modified BY： */@Componentpublic class RedisConfig {    public final static String CAHCENAME = &quot;CatalpaFlat&quot;;// 缓存名    public final static int CAHCETIME = 60;// 默认缓存时间 60S    public final static int CAHCEHOUR = 60 * 60;// 默认缓存时间 1hr    public final static int CAHCEDAY = 60 * 60 * 24;// 默认缓存时间 1Day    public final static int CAHCEWEEK = 60 * 60 * 24 * 7;// 默认缓存时间 1week    public final static int CAHCEMONTH = 60 * 60 * 24 * 7 * 30;// 默认缓存时间 1month    public final static int CAHCEYEAR = 60 * 60 * 24 * 7 * 30 * 12;// 默认缓存时间 1年    @Autowired    private RedisTemplate&lt;String, String&gt; redisTemplate;    public &lt;T&gt; boolean putCache(String key, T obj) {        final byte[] bkey = key.getBytes();        final byte[] bvalue = ProtoStuffSerializerUtil.serialize(obj);        boolean result = redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.setNX(bkey, bvalue));        return result;    }    public &lt;T&gt; void putCacheWithExpireTime(String key, T obj, final long expireTime) {        final byte[] bkey = key.getBytes();        final byte[] bvalue = ProtoStuffSerializerUtil.serialize(obj);        redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; {            connection.setEx(bkey, expireTime, bvalue);            return true;        });    }    public &lt;T&gt; boolean putListCache(String key, List&lt;T&gt; objList) {        final byte[] bkey = key.getBytes();        final byte[] bvalue = ProtoStuffSerializerUtil.serializeList(objList);        boolean result = redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.setNX(bkey, bvalue));        return result;    }    public &lt;T&gt; boolean putListCacheWithExpireTime(String key, List&lt;T&gt; objList, final long expireTime) {        final byte[] bkey = key.getBytes();        final byte[] bvalue = ProtoStuffSerializerUtil.serializeList(objList);        boolean result = redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; {            connection.setEx(bkey, expireTime, bvalue);            return true;        });        return result;    }    public &lt;T&gt; T getCache(final String key, Class&lt;T&gt; targetClass) {        byte[] result = redisTemplate.execute(new RedisCallback&lt;byte[]&gt;() {            @Override            public byte[] doInRedis(RedisConnection connection) throws DataAccessException {                return connection.get(key.getBytes());            }        });        if (result == null) {            return null;        }        return ProtoStuffSerializerUtil.deserialize(result, targetClass);    }    public &lt;T&gt; List&lt;T&gt; getListCache(final String key, Class&lt;T&gt; targetClass) {        byte[] result = redisTemplate.execute(new RedisCallback&lt;byte[]&gt;() {            @Override            public byte[] doInRedis(RedisConnection connection) throws DataAccessException {                return connection.get(key.getBytes());            }        });        if (result == null) {            return null;        }        return ProtoStuffSerializerUtil.deserializeList(result, targetClass);    }    /**     * 精确删除key     *     * @param key     */    public void deleteCache(String key) {        redisTemplate.delete(key);    }    /**     * 模糊删除key     *     * @param pattern     */    public void deleteCacheWithPattern(String pattern) {        Set&lt;String&gt; keys = redisTemplate.keys(pattern);        redisTemplate.delete(keys);    }    /**     * 清空所有缓存     */    public void clearCache() {        deleteCacheWithPattern(RedisConfig.CAHCENAME + &quot;|*&quot;);    }}</code></pre><h2 id="4-测试序列化工具类"><a href="#4-测试序列化工具类" class="headerlink" title="4.测试序列化工具类"></a>4.测试序列化工具类</h2><p>注：基于这篇文章<br><a href="http://blog.csdn.net/DuShiWoDeCuo/article/details/78506579" target="_blank" rel="noopener">http://blog.csdn.net/DuShiWoDeCuo/article/details/78506579</a><br>    /**</p><pre><code> * @Author： CatalpaFlat * @Descrition: * @Date: Create in 10:08 2017/11/8 * @Modified BY： */@RunWith(SpringRunner.class)@ContextConfiguration({&quot;classpath:spring/*.xml&quot;})public class TestRedis {    @Resource    private RedisConfig redisConfig;    @Autowired(required=true)    private RedisKeyUtil redisKeyUtil;    @Autowired    private RedisTemplate redisTemplate;    private static final Logger log  = Logger.getLogger(TestRedis.class.getName());    @Test    public void test(){//        redisTemplate.opsForValue().set(&quot;chen&quot;, &quot;陈梓平&quot;);//        log.info(&quot;value：&quot;+redisTemplate.opsForValue().get(&quot;chen&quot;));        String key = redisKeyUtil.getSystemRedisKeyDistribution(&quot;Test&quot;, this.getClass().getName(), &quot;test&quot;);        log.info(&quot;cache-key:&quot;+key);        redisConfig.putCache(key,&quot;测试链接&quot;);        String cache = redisConfig.getCache(key, String.class);        log.info(&quot;cache-value:&quot;+cache);    }}</code></pre><p><img src="https://i.imgur.com/kW8Yn27.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义超实用Redis工具类（满足对象，list，map等类型）&quot;&gt;&lt;a href=&quot;#自定义超实用Redis工具类（满足对象，list，map等类型）&quot; class=&quot;headerlink&quot; title=&quot;自定义超实用Redis工具类（满足对象，list，map
      
    
    </summary>
    
      <category term="Java" scheme="https://catalpaflat.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://catalpaflat.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置多虚拟主机（即配置域名）</title>
    <link href="https://catalpaflat.github.io/2017/08/27/nginx/Nginx%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%EF%BC%88%E5%8D%B3%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%EF%BC%89/"/>
    <id>https://catalpaflat.github.io/2017/08/27/nginx/Nginx配置多虚拟主机（即配置域名）/</id>
    <published>2017-08-27T13:33:54.000Z</published>
    <updated>2018-03-28T13:14:04.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx配置多虚拟主机（即配置域名）"><a href="#Nginx配置多虚拟主机（即配置域名）" class="headerlink" title="Nginx配置多虚拟主机（即配置域名）"></a>Nginx配置多虚拟主机（即配置域名）</h1><h2 id="1-存放站点（即项目）"><a href="#1-存放站点（即项目）" class="headerlink" title="1.存放站点（即项目）"></a>1.存放站点（即项目）</h2><p>站点的根目录和域名相同</p><h3 id="1-1-创建a域名存放地址"><a href="#1-1-创建a域名存放地址" class="headerlink" title="1.1.创建a域名存放地址"></a>1.1.创建a域名存放地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/site/a.chen.com</span><br></pre></td></tr></table></figure><h3 id="1-2-创建a域名的首页"><a href="#1-2-创建a域名的首页" class="headerlink" title="1.2.创建a域名的首页"></a>1.2.创建a域名的首页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/site/a.chen.com</span><br><span class="line">touch inde.html</span><br><span class="line">echo &apos;this is a from chen com...&apos; &gt; /data/site/a.chen.com/inde.html</span><br></pre></td></tr></table></figure><h3 id="1-3-创建b域名存放地址"><a href="#1-3-创建b域名存放地址" class="headerlink" title="1.3.创建b域名存放地址"></a>1.3.创建b域名存放地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/site/b.chen.com</span><br></pre></td></tr></table></figure><h3 id="1-4-创建b域名的首页"><a href="#1-4-创建b域名的首页" class="headerlink" title="1.4.创建b域名的首页"></a>1.4.创建b域名的首页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/site/b.chen.com</span><br><span class="line">touch inde.html</span><br><span class="line">echo &apos;this is b from chen com...&apos; &gt; /data/site/b.chen.com/inde.html</span><br></pre></td></tr></table></figure><h3 id="1-5-添加日志存放目录"><a href="#1-5-添加日志存放目录" class="headerlink" title="1.5.添加日志存放目录"></a>1.5.添加日志存放目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/logs/nginx</span><br></pre></td></tr></table></figure><h2 id="2-配置nginx的配置文件"><a href="#2-配置nginx的配置文件" class="headerlink" title="2.配置nginx的配置文件"></a>2.配置nginx的配置文件</h2><p>（注：若还没安装nginx的话，详情请看这一篇文章</p><blockquote><p><a href="http://blog.csdn.net/dushiwodecuo/article/details/78393454）" target="_blank" rel="noopener">http://blog.csdn.net/dushiwodecuo/article/details/78393454）</a></p></blockquote><h3 id="2-1-进入nginx配置目录"><a href="#2-1-进入nginx配置目录" class="headerlink" title="2.1.进入nginx配置目录"></a>2.1.进入nginx配置目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf/</span><br></pre></td></tr></table></figure><h3 id="2-2-编辑nginx-conf"><a href="#2-2-编辑nginx-conf" class="headerlink" title="2.2.编辑nginx.conf"></a>2.2.编辑nginx.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><h4 id="2-2-1-配置nginx日志格式"><a href="#2-2-1-配置nginx日志格式" class="headerlink" title="2.2.1.配置nginx日志格式"></a>2.2.1.配置nginx日志格式</h4><p>在nginx.conf中找到如下内容，并且将#注释标志去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line"># &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line"># &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-配置nginx主配置内容"><a href="#2-2-2-配置nginx主配置内容" class="headerlink" title="2.2.2.配置nginx主配置内容"></a>2.2.2.配置nginx主配置内容</h4><p>a域名服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">server_name a.chen.com;</span><br><span class="line">listen 80;</span><br><span class="line">root /data/site/a.chen.com;</span><br><span class="line">access_log /data/logs/nginx/a.chen.com-access.log main;</span><br><span class="line">    location /</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>b域名服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">server_name b.chen.com;</span><br><span class="line">listen 80;</span><br><span class="line">root /data/site/b.chen.com;</span><br><span class="line">access_log /data/logs/nginx/b.chen.com-access.log main;</span><br><span class="line">    location /</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置解析：</p><ul><li>server{}：配置虚拟主机必须有的的段</li><li><p>server_name:虚拟主机的域名，可以写多个域名，类似于别名，比如说你可以配置成：（这样的话，任何一个域名，内容都是一样的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name a.chen.com b.chen.com c.chen.com</span><br></pre></td></tr></table></figure></li><li><p>listen：127.0.0.1:80 监听端口</p></li><li>root ：站点根目录，网站文件存放的地方。（注：站点目录和域名尽量一样）</li><li>access_log：访问日志</li><li>location /{}：默认uri</li></ul><h3 id="3-检查nginx配置是否正确"><a href="#3-检查nginx配置是否正确" class="headerlink" title="3.检查nginx配置是否正确"></a>3.检查nginx配置是否正确</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure><ul><li>若出现以下两行ok和successful，表示配置没问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-重启nginx"><a href="#4-重启nginx" class="headerlink" title="4.重启nginx"></a>4.重启nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><ul><li>（注：若是之前没有启动过，则启动即可，但若启动过了，应该重启，不然会出现后面配置成功后但是访问域名却一直是nginx的欢迎界面）<h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h4><h4 id="5-1-Windows下测试"><a href="#5-1-Windows下测试" class="headerlink" title="5.1.Windows下测试"></a>5.1.Windows下测试</h4>修改hosts文件：C:\Windows\System32\drivers\etc，添加以下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.111 a.chen.com</span><br><span class="line">192.168.1.111 b.chen.com</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-Linux下测试"><a href="#5-2-Linux下测试" class="headerlink" title="5.2.Linux下测试"></a>5.2.Linux下测试</h4><p>修改hosts文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;192.168.1.111 a.chen.com 192.168.1.111 b.chen.com&apos; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure></p><h4 id="5-3-测试结果"><a href="#5-3-测试结果" class="headerlink" title="5.3.测试结果"></a>5.3.测试结果</h4><p>浏览器直接输入：a.chen.com 和 b.chen.com<br><img src="https://i.imgur.com/LTz299K.png" alt=""><br>Linux测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://a.chen.com</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/CvBAEYK.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx配置多虚拟主机（即配置域名）&quot;&gt;&lt;a href=&quot;#Nginx配置多虚拟主机（即配置域名）&quot; class=&quot;headerlink&quot; title=&quot;Nginx配置多虚拟主机（即配置域名）&quot;&gt;&lt;/a&gt;Nginx配置多虚拟主机（即配置域名）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx root&amp;alias文件路径配置解析</title>
    <link href="https://catalpaflat.github.io/2017/08/26/nginx/Nginx%20root&amp;alias%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://catalpaflat.github.io/2017/08/26/nginx/Nginx root&amp;alias文件路径配置解析/</id>
    <published>2017-08-26T14:43:43.000Z</published>
    <updated>2018-03-28T13:14:10.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-root-amp-alias文件路径配置解析"><a href="#Nginx-root-amp-alias文件路径配置解析" class="headerlink" title="Nginx root&amp;alias文件路径配置解析"></a>Nginx root&amp;alias文件路径配置解析</h1><ul><li>nginx在指定文件路径有两种方式root和alias，这两种的主要区别在于nginx如何解析location后面的uri，这会使两者分别以不同的方式请求映射到服务器的文件上。<h3 id="1-root语法的使用"><a href="#1-root语法的使用" class="headerlink" title="1.root语法的使用"></a>1.root语法的使用</h3>【root】<br>语法： root path<br>默认值： root html<br>配置段： http/server/location/if<br>例子:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ^~/chen/ &#123;</span><br><span class="line">root /data/www/www.chen.com;</span><br><span class="line">autoindex on;</span><br><span class="line">auto_basic &quot;Restricted&quot;;</span><br><span class="line">auto_basic_user_file passwd/chen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例子解析：<br>&emsp;&emsp;如果请求的uri是/chen/httplogs/<a href="http://www.chen.com-access.log时，web服务器将会返回服务器上的“/data/www/www.chen.com”(root的path)+“/chen/httplogs/www.chen.com-access.log”的文件。也就是说root路径配置会根据完整的uri请求来映射，也就是/path/uri" target="_blank" rel="noopener">www.chen.com-access.log时，web服务器将会返回服务器上的“/data/www/www.chen.com”(root的path)+“/chen/httplogs/www.chen.com-access.log”的文件。也就是说root路径配置会根据完整的uri请求来映射，也就是/path/uri</a></p><h3 id="2-alias语法的使用"><a href="#2-alias语法的使用" class="headerlink" title="2.alias语法的使用"></a>2.alias语法的使用</h3><p>【alias】<br>语法：alias path<br>配置段：location<br>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /binapp/ &#123;</span><br><span class="line">limit_conn limit 4;</span><br><span class="line">limit_rate 200k;</span><br><span class="line">internal;</span><br><span class="line">alias /data/statics/bin/apps/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子解析：<br>&emsp;&emsp;alias会把location后面配置的路径丢弃，把当前匹配到的目录指向到指定的目录。如果一个请求的uri是/binapp/a.chen.com/favicon时，web服务器将会返回服务器上的“/data/statics/bin/apps/”+“a.chen.com/favicon.html”的文件<br>&emsp;&emsp;alias使用总结：</p><ul><li>使用alias时，目录名后面一定要加“/“</li><li>alias可以指定任何名称</li><li>alias在使用正则表达式时，必须捕捉要匹配到的内容并在指定的内容处使用</li><li>alias只能位于location块中。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-root-amp-alias文件路径配置解析&quot;&gt;&lt;a href=&quot;#Nginx-root-amp-alias文件路径配置解析&quot; class=&quot;headerlink&quot; title=&quot;Nginx root&amp;amp;alias文件路径配置解析&quot;&gt;&lt;/a&gt;Ng
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx rewrite深入解读</title>
    <link href="https://catalpaflat.github.io/2017/08/26/nginx/Nginx%20rewrite%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/"/>
    <id>https://catalpaflat.github.io/2017/08/26/nginx/Nginx rewrite深入解读/</id>
    <published>2017-08-26T10:23:12.000Z</published>
    <updated>2018-03-28T13:12:50.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-rewrite深入解读"><a href="#Nginx-rewrite深入解读" class="headerlink" title="Nginx rewrite深入解读"></a>Nginx rewrite深入解读</h1><h2 id="1-什么是rewrite"><a href="#1-什么是rewrite" class="headerlink" title="1.什么是rewrite"></a>1.什么是rewrite</h2><p>官方解读：nginx的重写模块（rewrite）是一个简单的正则表达式匹配与一个虚拟堆叠机结合。<br>个人解读：nginx的rewrite是结合正则表达式和标志位实现url重写、改变以及重定向。如：域名跳转，防盗链，反向代理，各种跳转（跳转维护界面，前端跳转，基于uri跳转，基于目录跳转等）</p><hr><h2 id="2-rewrite的支撑源头"><a href="#2-rewrite的支撑源头" class="headerlink" title="2.rewrite的支撑源头"></a>2.rewrite的支撑源头</h2><p>nginx通过ngx_http_rewrite_module模块支持url重写、支持if条件判断。依赖于PCRE库，因此需要安装pcre。</p><hr><h2 id="3-rewrite的7个指令"><a href="#3-rewrite的7个指令" class="headerlink" title="3.rewrite的7个指令"></a>3.rewrite的7个指令</h2><h3 id="3-1-break"><a href="#3-1-break" class="headerlink" title="3.1.break"></a>3.1.break</h3><ul><li>语法：break</li><li>默认值：none</li><li>配置段：server,location,if</li><li>作用：完成当前设置的重写规则，停止处理后续rewrite指令集，并不在重新查找,但是当前location内剩余非rewrite语句和location外的的非rewrite语句可以执行。</li><li>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ($slow) &#123;</span><br><span class="line">limit_rate 10k;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-if"><a href="#3-2-if" class="headerlink" title="3.2.if"></a>3.2.if</h3><ul><li>语法：if(condition){…}</li><li>默认值：none</li><li>配置段：server,location</li><li>作用：对给定的条件condition进行判断</li><li>conditon：if条件(conditon)可以是如下任何内容:<ol><li>一个变量名:空字符传“ ”或者一些“0”开始的字符串为false</li><li>字符串比较：使用=或!=运算符</li><li>正则表达式匹配：用~或~*+正则表达式匹配的变量，如果这个正则表达式中包含}或;，则整个表达式需要用” 或’ 包围</li><li>文件是否存在：使用-f或者!-f操作符</li><li>目录是否存在：使用-d或者!-d操作符</li><li>文件、目录、符号链接是否存在：使用-e或者!-e操作符</li><li>文件是否可执行：使用-x或者!-x操作符</li></ol></li><li>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">set $id $1;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_user_agent ~ MSIE) &#123;    </span><br><span class="line">rewrite ^(.*)$ /msie/$1 </span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-return"><a href="#3-3-return" class="headerlink" title="3.3.return"></a>3.3.return</h3><ul><li>语法：<ul><li>return code；</li><li>return url；</li><li>return code url；</li></ul></li><li>默认值：none</li><li>配置段：server,location,if</li><li>作用：<ol><li>停止处理，并为客户端返回状态码。</li><li>非标准的444状态码将关闭连接，不发送任何响应头</li><li>可以使用的状态码有：204/400/402-406/408/410/411/413/416/500-504</li><li>如果状态码后面是一个url，该url将成为location头的补值。</li><li>没有状态码的url将被视为一个默认的302状态码</li><li>状态码附带文字段落，该文本将被放置在响应主体里</li></ol></li><li>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">     return 405;</span><br><span class="line">&#125;</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">     return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-rewrite"><a href="#3-4-rewrite" class="headerlink" title="3.4.rewrite"></a>3.4.rewrite</h3><ul><li>语法：rewrite regex replacement [flag];</li><li>默认值：none</li><li>配置段：server,location,if</li><li>作用：    <ol><li>如果一个URI匹配指定的正则表达式regex，URI就按照replacement重写</li><li>可以在重写指令后添加标识【flag】</li><li>flag标志可以停止继续处理</li><li>如果replacement以”http://“或”https://“开始，将不再继续处理rewrite指令，这个重定向将返回给客户端</li></ol></li><li>flag标识符可为以下值：<ol><li>last：停止处理后续rewrite指令集，然后对当前重写的新URI在rewrite指令集上重新查找。</li><li>break：完成rewrite指令，并不在重新查找,但是当前location内剩余非rewrite语句和location外的的非rewrite语句可以执行。</li><li>redirect：如果replacement不是以http:// 或https://开始，返回302临时重定向</li><li>permannet：返回301永久重定向</li></ol></li><li>最终完整的重定向URL包括请求scheme(http://,https://等),请求的server_name_in_redirect和 port_in_redirec三部分 ，说白了也就是http协议 域名 端口三部分组成。</li><li>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;     </span><br><span class="line">rewrite ^(/download/.*)/media/(.*)..*$ $1/mp3/$2.mp3 break;     </span><br><span class="line">rewrite ^(/download/.*)/audio/(.*)..*$ $1/mp3/$2.ra break;     </span><br><span class="line">return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-rewrite-log"><a href="#3-5-rewrite-log" class="headerlink" title="3.5.rewrite_log"></a>3.5.rewrite_log</h3><ul><li>语法：rewrite_log on|off;</li><li>默认值：rewrite_log off;</li><li>配置段：http,server,location,if</li><li>作用：启用时将在error log中记录notice级别的重写日志</li><li>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rewrite_log on;</span><br><span class="line">error_log logs/xxx.error.log notice;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-6-set"><a href="#3-6-set" class="headerlink" title="3.6.set"></a>3.6.set</h3><ul><li>语法：set variable value;</li><li>默认值：none</li><li>配置段：server,location,if</li><li>作用：定义一个变量并赋值，值可以是文本，变量或者文本变量混合体。<h3 id="3-7-uninitialized-variable-warn"><a href="#3-7-uninitialized-variable-warn" class="headerlink" title="3.7.uninitialized_variable_warn"></a>3.7.uninitialized_variable_warn</h3></li><li>语法：uninitialized_variable_warn on | off;</li><li>默认值：uninitialized_variable_warn on</li><li>作用域：http,server,location,if</li><li>作用：控制是否记录未初始化的警告信息</li><li></li></ul><hr><h2 id="4-rewrite的规则"><a href="#4-rewrite的规则" class="headerlink" title="4.rewrite的规则"></a>4.rewrite的规则</h2><h3 id="4-1-rewrite指令执行顺序"><a href="#4-1-rewrite指令执行顺序" class="headerlink" title="4.1.rewrite指令执行顺序"></a>4.1.rewrite指令执行顺序</h3><ol><li>执行server块的rewrite指令(这里的块指的是server关键字后{}包围的区域，其它xx块类似)</li><li>执行location匹配</li><li>执行选定的location中的rewrite指令</li><li>如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件<br>如果循环超过10次，则返回500 Internal Server Error错误<h3 id="4-2-正则表达式-引用取值"><a href="#4-2-正则表达式-引用取值" class="headerlink" title="4.2.正则表达式-引用取值"></a>4.2.正则表达式-引用取值</h3></li></ol><ul><li>可以使用括号来捕获，后续可用位置来将其引用，位置变量取决于捕获正则表达式中的顺序，$1引用第一个括号（）中值，$2则引用第二个括号中的值</li><li><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^/img/([a-z]&#123;2&#125;)/([a-z0-9]&#123;5&#125;)/(.*)\.(png|gif|jpg)$</span><br></pre></td></tr></table></figure><p>1） $1:是([a-z]{2})，两个小写字母组成的字符串<br>2） $2:是([a-z0-9]{5})，由小写字母或0-9组成的5个字符串<br>3） $3:是(.*)，是文件名<br>4） $4:是(png|gif|jpg)，其中一个</p><h3 id="4-3-return返回规则"><a href="#4-3-return返回规则" class="headerlink" title="4.3.return返回规则"></a>4.3.return返回规则</h3></li></ul><ol><li>停止处理，并为客户端返回状态码。</li><li>非标准的444状态码将关闭连接，不发送任何响应头</li><li>可以使用的状态码有：204/400/402-406/408/410/411/413/416/500-504</li><li>如果状态码后面是一个url，该url将成为location头的补值。</li><li>没有状态码的url将被视为一个默认的302状态码</li><li>状态码附带文字段落，该文本将被放置在响应主体里<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /img404.html&#123;</span><br><span class="line">return 404 &quot;image not found\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="5-rewrite小实例"><a href="#5-rewrite小实例" class="headerlink" title="5.rewrite小实例"></a>5.rewrite小实例</h2><h3 id="5-1-禁止-sh-bash"><a href="#5-1-禁止-sh-bash" class="headerlink" title="5.1.禁止.sh .bash"></a>5.1.禁止.sh .bash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(sh|bash)?$&#123;  </span><br><span class="line">  return 403;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/6FjAULs.png" alt=""> </p><hr><h3 id="5-2-目录跳转"><a href="#5-2-目录跳转" class="headerlink" title="5.2.目录跳转"></a>5.2.目录跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /a&#123;</span><br><span class="line">         alias /data/site/b.chen.com/a;</span><br><span class="line">         rewrite ^/a/?$ /b last;</span><br><span class="line">&#125;</span><br><span class="line">location /b&#123;</span><br><span class="line">        alias /data/site/b.chen.com/b;</span><br><span class="line">        default_type &apos;text/html&apos;;</span><br><span class="line">        echo &quot;url is a -&gt; rewrite to b...&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/sDD29j1.png" alt=""></p><hr><h3 id="5-3-防盗链实例"><a href="#5-3-防盗链实例" class="headerlink" title="5.3.防盗链实例"></a>5.3.防盗链实例</h3><h4 id="5-3-0-valid-referer指令说明"><a href="#5-3-0-valid-referer指令说明" class="headerlink" title="5.3.0.valid_referer指令说明"></a>5.3.0.valid_referer指令说明</h4><p>Nginx配置中有一个指令valid_referers，用来获取Referer头域中的值，并且根据该值的情况给Nginx全局变量$invalid_referer的值，如果Referer头域中没有符合valid_referers指令配置的值，$invalid_referer变量将会被赋值为1。<br>valid_referer指令的语法结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valid_referers none | blocked | server_names | string ....;</span><br><span class="line">none 检测Referer头域不存在的请求</span><br><span class="line">blocked 检测Referer头域的值被防火墙或者代理服务器删除或伪装的情况。</span><br><span class="line">这种情况下，该头域的值不以“http://”或者“https：//”开头</span><br><span class="line">server_names 设置一个或多个URL,检测Referer头域的值是否是这些URL中的某个。</span><br><span class="line">从nginx 0.5.33以后支持使用通配符“*”。</span><br></pre></td></tr></table></figure></p><h4 id="5-3-1-nginx-conf的server配置"><a href="#5-3-1-nginx-conf的server配置" class="headerlink" title="5.3.1.nginx.conf的server配置"></a>5.3.1.nginx.conf的server配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    server_name echo.chen.com;</span><br><span class="line">    listen 80;</span><br><span class="line">    location /&#123;</span><br><span class="line">        root /data/site/echo.chen.com;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">location ~ .*\.(jpg|png)$ &#123;</span><br><span class="line">        valid_referers none blocked echo.chen.com;</span><br><span class="line">        if ($invalid_referer) &#123;</span><br><span class="line">                return 412;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">       root /data/site/echo.chen.com;</span><br><span class="line">    &#125;</span><br><span class="line">    location =/error.html&#123;</span><br><span class="line">            root /data/site/echo.chen.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>/data/site/echo.chen.com 自行创建目录</li><li>index.html内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is index.html</span><br><span class="line">&lt;img src=&quot;http://echo.chen.com/1.jpg&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-3-2-Windows下host配置"><a href="#5-3-2-Windows下host配置" class="headerlink" title="5.3.2.Windows下host配置"></a>5.3.2.Windows下host配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.111 b.chen.com</span><br><span class="line">192.168.1.111 echo.chen.com</span><br></pre></td></tr></table></figure><ul><li>配置不同域名指定同一个ip，以便测试<h4 id="5-3-3-浏览器测试"><a href="#5-3-3-浏览器测试" class="headerlink" title="5.3.3.浏览器测试"></a>5.3.3.浏览器测试</h4>访问指定的域名，即可访问到图片<br><img src="https://i.imgur.com/D7uzwFv.png" alt=""><br>使用b.chen.com进行访问则不能访问到服务器图片<br><img src="https://i.imgur.com/ZdjnR8Q.png" alt=""></li></ul><hr><h3 id="5-4-域名跳转"><a href="#5-4-域名跳转" class="headerlink" title="5.4.域名跳转"></a>5.4.域名跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    server_name jump.chen.com;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line">    location /&#123;</span><br><span class="line">            default_type &quot;text/html&quot;;</span><br><span class="line">            echo &quot;it is echo.chen.com jump to jump.chen.com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    server_name echo.chen.com;</span><br><span class="line">    listen 80;</span><br><span class="line">    rewrite ^/ http://jump.chen.com/;</span><br><span class="line">    location /&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/xRbRVPg.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-rewrite深入解读&quot;&gt;&lt;a href=&quot;#Nginx-rewrite深入解读&quot; class=&quot;headerlink&quot; title=&quot;Nginx rewrite深入解读&quot;&gt;&lt;/a&gt;Nginx rewrite深入解读&lt;/h1&gt;&lt;h2 id=&quot;1-什么是
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx location配置解析</title>
    <link href="https://catalpaflat.github.io/2017/08/24/nginx/Nginx%20location%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://catalpaflat.github.io/2017/08/24/nginx/Nginx location配置解析/</id>
    <published>2017-08-24T15:34:12.000Z</published>
    <updated>2018-03-28T13:12:08.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-location配置解析"><a href="#Nginx-location配置解析" class="headerlink" title="Nginx location配置解析"></a>Nginx location配置解析</h1><h3 id="1-语法规则"><a href="#1-语法规则" class="headerlink" title="1.语法规则"></a>1.语法规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~]/uri/&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>=  表示精确匹配，这个优先级最高的</li><li>^~ 表示uri以某个常规字符串开头，理解为匹配 url路径即可，Nginx不对url做编码，因此请求为/static/80%/aa,可以被规则^~/static/ /aa(注意中间是空格)</li><li>~  表示区分大小写的正则匹配、</li><li>~* 表示不区分大小写的正则匹配</li><li>!~ 表示区分大小写不正则匹配</li><li>!~*表示不区分大小写不正则匹配</li><li>/  表示通用匹配，任何请求都会匹配到，默认匹配<br>其中常用正则</li><li>. ： 匹配除换行符以外的任意字符</li><li>? ： 重复0次或1次</li><li>+ ： 重复1次或更多次</li><li>* ： 重复0次或更多次</li><li>\d ：匹配数字</li><li>^ ： 匹配字符串的开始</li><li>$ ： 匹配字符串的介绍</li><li>{n} ： 重复n次</li><li>{n,} ： 重复n次或更多次</li><li>[c] ： 匹配单个字符c</li><li>[a-z] ： 匹配a-z小写字母的任意一个<h3 id="2-语法优先级别"><a href="#2-语法优先级别" class="headerlink" title="2.语法优先级别"></a>2.语法优先级别</h3>优先级：= &gt; ^~<br>首先匹配 = ，其次匹配 ^~，其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则请求。<h3 id="3-定义匹配规则"><a href="#3-定义匹配规则" class="headerlink" title="3.定义匹配规则"></a>3.定义匹配规则</h3>(注：需要安装echo模块才行，才能使用echo)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">echo &apos;/&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /&#123;</span><br><span class="line">echo &apos;=/&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /nginx&#123;</span><br><span class="line">echo &apos;=/nginx&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.(gif|jpg|png|js|css) &#123;</span><br><span class="line">echo &apos;name-gif/jpg/png&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.png$ &#123;</span><br><span class="line">echo &apos;all-png&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /static/ &#123;</span><br><span class="line">echo &apos;static&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-访问测试"><a href="#4-访问测试" class="headerlink" title="4.访问测试"></a>4.访问测试</h3><ul><li><p>访问<a href="http://a.chen.com/，匹配到“=/”" target="_blank" rel="noopener">http://a.chen.com/，匹配到“=/”</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#curl http://a.chen.com/</span><br><span class="line">=/</span><br></pre></td></tr></table></figure></li><li><p>访问<a href="http://a.chen.com/nginx，完全匹配到“=/nginx”" target="_blank" rel="noopener">http://a.chen.com/nginx，完全匹配到“=/nginx”</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#curl http://a.chen.com/nginx</span><br><span class="line">=/nginx</span><br></pre></td></tr></table></figure></li><li><p>访问<a href="http://a.chen.com/xxx/xxx.PNG，完全匹配到“~" target="_blank" rel="noopener">http://a.chen.com/xxx/xxx.PNG，完全匹配到“~</a>* .png$，因为大写。所以没有匹配到‘~.(gif|jpg|png|js|css)’，因为 ~ 区分大小写 ”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#curl http://a.chen.com/xxx/1.PNG</span><br><span class="line">all-png</span><br></pre></td></tr></table></figure></li><li><p>访问<a href="http://a.chen.com/static/xxx.PNG，匹配到“" target="_blank" rel="noopener">http://a.chen.com/static/xxx.PNG，匹配到“</a> ^~ /static/ 因为有 ^~ 停止往下匹配了”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#curl http://a.chen.com/static/1.PNG</span><br><span class="line">static</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-常用的静态资源匹配规则"><a href="#5-常用的静态资源匹配规则" class="headerlink" title="5.常用的静态资源匹配规则"></a>5.常用的静态资源匹配规则</h3><h4 id="5-1-样式和JS"><a href="#5-1-样式和JS" class="headerlink" title="5.1.样式和JS"></a>5.1.样式和JS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* .*\.(js|css)?$&#123;</span><br><span class="line">expires 7d;//7天过期</span><br><span class="line">access_log off;//不保存日志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-图片图标等"><a href="#5-5-图片图标等" class="headerlink" title="5.5.图片图标等"></a>5.5.图片图标等</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* .*\.(jpg|png|gif|jpeg|bmp|ico)?$&#123;</span><br><span class="line">expires 7d;//7天过期</span><br><span class="line">access_log off;//不保存日志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-资源数据"><a href="#5-6-资源数据" class="headerlink" title="5.6.资源数据"></a>5.6.资源数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* .*\.(zip|rar|exe|msi|iso|gho|mp3|mp4|rmvb|wma|wmv|rm)?$&#123;</span><br><span class="line">deny all;//禁止这些文件的下载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-location配置解析&quot;&gt;&lt;a href=&quot;#Nginx-location配置解析&quot; class=&quot;headerlink&quot; title=&quot;Nginx location配置解析&quot;&gt;&lt;/a&gt;Nginx location配置解析&lt;/h1&gt;&lt;h3 id=&quot;1
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 日志配置详情解析</title>
    <link href="https://catalpaflat.github.io/2017/08/24/nginx/Nginx%20%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E8%AF%A6%E6%83%85%E8%A7%A3%E6%9E%90/"/>
    <id>https://catalpaflat.github.io/2017/08/24/nginx/Nginx 日志配置详情解析/</id>
    <published>2017-08-24T13:22:56.000Z</published>
    <updated>2018-03-28T13:11:38.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-日志配置详情解析"><a href="#Nginx-日志配置详情解析" class="headerlink" title="Nginx 日志配置详情解析"></a>Nginx 日志配置详情解析</h1><p>&emsp;&emsp;在使用nginx进行服务器管理时候，日志对于统计、审查、排错来说非常有利。<br>&emsp;&emsp;nginx日志相关的配置有：access_log(访问日志)、log_format（日志格式）、open_log_file_cache、log_not_found、log_subrequest、rewrite_log、error_log。<br>&emsp;&emsp;nginx有一个非常灵活的日志记录模式，每个级别的配置可以有各自独立的访问日志。日志格式通过log_format命令来定义。（主要基于ngx_http_log_module:用于定义请求日志格式）</p><h2 id="1-access-log配置解析"><a href="#1-access-log配置解析" class="headerlink" title="1.access_log配置解析"></a>1.access_log配置解析</h2><h3 id="1-1-access-log语法"><a href="#1-1-access-log语法" class="headerlink" title="1.1.access_log语法"></a>1.1.access_log语法</h3><ul><li>access_log path [format [buffer=size [flush=time]]]</li><li>access_log path format gzip[=level] [buffer=size [flush=time]]</li><li>access_log syslog:server=address[,parameter=value][format]</li><li>access_log off<h3 id="1-2-access-log默认值"><a href="#1-2-access-log默认值" class="headerlink" title="1.2.access_log默认值"></a>1.2.access_log默认值</h3></li><li>access_log log/access.log combined<h3 id="1-3-access-log配置段"><a href="#1-3-access-log配置段" class="headerlink" title="1.3.access_log配置段"></a>1.3.access_log配置段</h3></li><li>http</li><li>server</li><li>location</li><li>if in location</li><li>limit_except<h3 id="1-4-access-log语法参数解析"><a href="#1-4-access-log语法参数解析" class="headerlink" title="1.4.access_log语法参数解析"></a>1.4.access_log语法参数解析</h3></li><li>gzip：压缩等级</li><li>buffer：设置所需内容缓存区大小</li><li>flush：保存在缓存区的最长时间</li><li>off：不记录日志</li><li>combined：使用默认的格式记录日志（access_log log/access.log combined或access_log log/access.log）</li></ul><hr><h2 id="2-log-format配置解析"><a href="#2-log-format配置解析" class="headerlink" title="2.log_format配置解析"></a>2.log_format配置解析</h2><h3 id="2-1-log-format语法"><a href="#2-1-log-format语法" class="headerlink" title="2.1.log_format语法"></a>2.1.log_format语法</h3><ul><li>log_format name string …;<h3 id="2-2-log-format默认值"><a href="#2-2-log-format默认值" class="headerlink" title="2.2.log_format默认值"></a>2.2.log_format默认值</h3></li><li>log_format combined “…”;<br>log_format有一个默认的无需设置的combined日志格式，相当于apache的combined日志格式。格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  combined  &apos;$remote_addr - $remote_user  [$time_local]  &apos;</span><br><span class="line">                                   &apos; &quot;$request&quot;  $status  $body_bytes_sent  &apos;</span><br><span class="line">                                   &apos; &quot;$http_referer&quot;  &quot;$http_user_agent&quot; &apos;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-log-format配置段"><a href="#2-3-log-format配置段" class="headerlink" title="2.3.log_format配置段"></a>2.3.log_format配置段</h3><ul><li>http<h3 id="2-4-log-format语法参数解析"><a href="#2-4-log-format语法参数解析" class="headerlink" title="2.4.log_format语法参数解析"></a>2.4.log_format语法参数解析</h3></li><li>name表示格式名称</li><li>string表示等义的格式。<h3 id="2-5-log-format常用的变量参数："><a href="#2-5-log-format常用的变量参数：" class="headerlink" title="2.5.log_format常用的变量参数："></a>2.5.log_format常用的变量参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$remote_addr, $http_x_forwarded_for（反向） 记录客户端IP地址</span><br><span class="line">$remote_user 记录客户端用户名称</span><br><span class="line">$request 记录请求的URL和HTTP协议</span><br><span class="line">$status 记录请求状态</span><br><span class="line">$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。</span><br><span class="line">$bytes_sent 发送给客户端的总字节数。</span><br><span class="line">$connection 连接的序列号。</span><br><span class="line">$connection_requests 当前通过一个连接获得的请求数量。</span><br><span class="line">$msec 日志写入时间。单位为秒，精度是毫秒。</span><br><span class="line">$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。</span><br><span class="line">$http_referer 记录从哪个页面链接访问过来的</span><br><span class="line">$http_user_agent 记录客户端浏览器相关信息</span><br><span class="line">$request_length 请求的长度（包括请求行，请求头和请求正文）。</span><br><span class="line">$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span><br><span class="line">$time_iso8601 ISO8601标准格式下的本地时间。</span><br><span class="line">$time_local 通用日志格式下的本地时间。</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6-log-format使用例子"><a href="#2-6-log-format使用例子" class="headerlink" title="2.6.log_format使用例子"></a>2.6.log_format使用例子</h3><h4 id="2-6-1-nginx反向代理时配置log-format"><a href="#2-6-1-nginx反向代理时配置log-format" class="headerlink" title="2.6.1.nginx反向代理时配置log_format"></a>2.6.1.nginx反向代理时配置log_format</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  porxy  &apos;$http_x_forwarded_for - $remote_user  [$time_local]  &apos;</span><br><span class="line">                   &apos; &quot;$request&quot;  $status $body_bytes_sent &apos;</span><br><span class="line">                   &apos; &quot;$http_referer&quot;  &quot;$http_user_agent&quot; &apos;;</span><br></pre></td></tr></table></figure><ul><li><p>注：nginx位于负载均衡器，squid，nginx反向代理之后，web服务器无法直接获取到客户端真实的IP地址了。 $remote_addr获取反向代理的IP地址。反向代理服务器在转发请求的http头信息中，可以增加X-Forwarded-For信息，用来记录 客户端IP地址和客户端请求的服务器地址。</p><h4 id="2-6-2-http发送给客户端时配置log-format"><a href="#2-6-2-http发送给客户端时配置log-format" class="headerlink" title="2.6.2.http发送给客户端时配置log_format"></a>2.6.2.http发送给客户端时配置log_format</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"> log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                   &apos;&quot;$status&quot; $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;</span><br><span class="line">                   &apos;&quot;$gzip_ratio&quot; $request_time $bytes_sent $request_length&apos;;</span><br><span class="line"> </span><br><span class="line"> log_format srcache_log &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                        &apos;&quot;$status&quot; $body_bytes_sent $request_time $bytes_sent $request_length &apos;</span><br><span class="line">                        &apos;[$upstream_response_time] [$srcache_fetch_status] [$srcache_store_status] [$srcache_expire]&apos;;</span><br><span class="line"> </span><br><span class="line"> open_log_file_cache max=1000 inactive=60s;</span><br><span class="line"></span><br><span class="line"> server &#123;</span><br><span class="line"> server_name ~^(www\.)?(.+)$;</span><br><span class="line"> access_log logs/$2-access.log main;</span><br><span class="line"> error_log logs/$2-error.log;</span><br><span class="line">location /srcache &#123;</span><br><span class="line"> access_log logs/access-srcache.log srcache_log;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：发送给客户端的响应头拥有“sent_http_”前缀。 比如$sent_http_content_range。</p></li><li></li></ul><hr><h2 id="3-open-log-file-cache配置解析"><a href="#3-open-log-file-cache配置解析" class="headerlink" title="3.open_log_file_cache配置解析"></a>3.open_log_file_cache配置解析</h2><h3 id="3-1-open-log-file-cache语法"><a href="#3-1-open-log-file-cache语法" class="headerlink" title="3.1.open_log_file_cache语法"></a>3.1.open_log_file_cache语法</h3><ul><li>open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];</li><li>open_log_file_cache off;<h3 id="3-2-open-log-file-cache默认值"><a href="#3-2-open-log-file-cache默认值" class="headerlink" title="3.2.open_log_file_cache默认值"></a>3.2.open_log_file_cache默认值</h3></li><li>open_log_file_cache off;<h3 id="3-3-open-log-file-cache配置段"><a href="#3-3-open-log-file-cache配置段" class="headerlink" title="3.3.open_log_file_cache配置段"></a>3.3.open_log_file_cache配置段</h3></li><li>http</li><li>server</li><li>location<h3 id="3-4-open-log-file-cache语法参数解析"><a href="#3-4-open-log-file-cache语法参数解析" class="headerlink" title="3.4.open_log_file_cache语法参数解析"></a>3.4.open_log_file_cache语法参数解析</h3></li><li>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用LRU算法将描述符关闭。</li><li>inactive:设置存活时间，默认是10s</li><li>min_uses:设置在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次</li><li>valid:设置检查频率，默认60s</li><li>off：禁用缓存<h3 id="3-5-open-log-file-cache的作用"><a href="#3-5-open-log-file-cache的作用" class="headerlink" title="3.5.open_log_file_cache的作用"></a>3.5.open_log_file_cache的作用</h3>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)<h3 id="3-6-open-log-file-cache使用例子"><a href="#3-6-open-log-file-cache使用例子" class="headerlink" title="3.6.open_log_file_cache使用例子"></a>3.6.open_log_file_cache使用例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</span><br><span class="line">open_log_file_cache off;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-log-not-found配置解析"><a href="#4-log-not-found配置解析" class="headerlink" title="4.log_not_found配置解析"></a>4.log_not_found配置解析</h2><h3 id="4-1-log-not-found语法"><a href="#4-1-log-not-found语法" class="headerlink" title="4.1.log_not_found语法"></a>4.1.log_not_found语法</h3><ul><li>log_not_found on | off;<h3 id="4-2-log-not-found默认值"><a href="#4-2-log-not-found默认值" class="headerlink" title="4.2.log_not_found默认值"></a>4.2.log_not_found默认值</h3></li><li>log_not_found on;<h3 id="4-3-log-not-found配置段"><a href="#4-3-log-not-found配置段" class="headerlink" title="4.3.log_not_found配置段"></a>4.3.log_not_found配置段</h3></li><li>http</li><li>server</li><li>location<h3 id="4-4-log-not-found的作用"><a href="#4-4-log-not-found的作用" class="headerlink" title="4.4.log_not_found的作用"></a>4.4.log_not_found的作用</h3>是否在error_log中记录不存在的错误。默认是。</li></ul><hr><h2 id="5-log-subrequest配置解析"><a href="#5-log-subrequest配置解析" class="headerlink" title="5.log_subrequest配置解析"></a>5.log_subrequest配置解析</h2><h3 id="5-1-log-subrequest语法"><a href="#5-1-log-subrequest语法" class="headerlink" title="5.1.log_subrequest语法"></a>5.1.log_subrequest语法</h3><ul><li>log_subrequest on | off;<h3 id="5-2-log-subrequest默认值"><a href="#5-2-log-subrequest默认值" class="headerlink" title="5.2.log_subrequest默认值"></a>5.2.log_subrequest默认值</h3></li><li>log_subrequest off;<h3 id="5-3-log-subrequest配置段"><a href="#5-3-log-subrequest配置段" class="headerlink" title="5.3.log_subrequest配置段"></a>5.3.log_subrequest配置段</h3></li><li>http</li><li>server</li><li>location<h3 id="5-4-log-subrequest的作用"><a href="#5-4-log-subrequest的作用" class="headerlink" title="5.4.log_subrequest的作用"></a>5.4.log_subrequest的作用</h3>是否在access_log中记录子请求的访问日志。默认不记录。</li></ul><hr><h2 id="6-rewrite-log配置解析"><a href="#6-rewrite-log配置解析" class="headerlink" title="6.rewrite_log配置解析"></a>6.rewrite_log配置解析</h2><h3 id="6-1-rewrite-log语法"><a href="#6-1-rewrite-log语法" class="headerlink" title="6.1.rewrite_log语法"></a>6.1.rewrite_log语法</h3><ul><li>rewrite_log on | off;<h3 id="6-2-rewrite-log默认值"><a href="#6-2-rewrite-log默认值" class="headerlink" title="6.2.rewrite_log默认值"></a>6.2.rewrite_log默认值</h3></li><li>rewrite_log off;<h3 id="6-3-rewrite-log配置段"><a href="#6-3-rewrite-log配置段" class="headerlink" title="6.3.rewrite_log配置段"></a>6.3.rewrite_log配置段</h3></li><li>http</li><li>server</li><li>location</li><li>if<h3 id="6-4-rewrite-log的作用"><a href="#6-4-rewrite-log的作用" class="headerlink" title="6.4.rewrite_log的作用"></a>6.4.rewrite_log的作用</h3>启用时将在error log中记录notice级别的重写日志。<br>基于ngx_http_rewrite_module模块提供的。用来记录重写日志的。对于调试重写规则建议开启。</li></ul><hr><h2 id="7-error-log配置解析"><a href="#7-error-log配置解析" class="headerlink" title="7.error_log配置解析"></a>7.error_log配置解析</h2><h3 id="7-1-error-log语法"><a href="#7-1-error-log语法" class="headerlink" title="7.1.error_log语法"></a>7.1.error_log语法</h3><ul><li>error_log file | stderr | syslog:server=address[,parameter=value] [debug | info | notice | warn | error | crit | alert | emerg];<h3 id="7-2-error-log默认值"><a href="#7-2-error-log默认值" class="headerlink" title="7.2.error_log默认值"></a>7.2.error_log默认值</h3></li><li>error_log logs/error.log error;<h3 id="7-3-error-log配置段"><a href="#7-3-error-log配置段" class="headerlink" title="7.3.error_log配置段"></a>7.3.error_log配置段</h3></li><li>http</li><li>server</li><li>location</li><li>main<h3 id="7-4-error-log的作用"><a href="#7-4-error-log的作用" class="headerlink" title="7.4.error_log的作用"></a>7.4.error_log的作用</h3>配置错误日志。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-日志配置详情解析&quot;&gt;&lt;a href=&quot;#Nginx-日志配置详情解析&quot; class=&quot;headerlink&quot; title=&quot;Nginx 日志配置详情解析&quot;&gt;&lt;/a&gt;Nginx 日志配置详情解析&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在使用nginx进行
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>服务器快速集成Nginx</title>
    <link href="https://catalpaflat.github.io/2017/08/22/nginx/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E6%88%90Nginx/"/>
    <id>https://catalpaflat.github.io/2017/08/22/nginx/服务器集成Nginx/</id>
    <published>2017-08-22T07:23:54.000Z</published>
    <updated>2018-03-28T13:11:04.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器快速集成Nginx"><a href="#服务器快速集成Nginx" class="headerlink" title="服务器快速集成Nginx"></a>服务器快速集成Nginx</h1><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1.安装依赖"></a>1.安装依赖</h3><h4 id="1-1-pcre重定向依赖"><a href="#1-1-pcre重定向依赖" class="headerlink" title="1.1.pcre重定向依赖"></a>1.1.pcre重定向依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre*</span><br></pre></td></tr></table></figure><ul><li><p>PCRE(Perl Compatible Regular Expressions)是一个Perl库，不止具有http重定向依赖，还包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p><h4 id="1-2-openssl-http-https支持，如果不需要https可以不安装。"><a href="#1-2-openssl-http-https支持，如果不需要https可以不安装。" class="headerlink" title="1.2.openssl(http/https支持，如果不需要https可以不安装。"></a>1.2.openssl(http/https支持，如果不需要https可以不安装。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre*</span><br></pre></td></tr></table></figure></li><li><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p><h4 id="1-3-安装-Tengine-执行配置命令-gcc环境"><a href="#1-3-安装-Tengine-执行配置命令-gcc环境" class="headerlink" title="1.3.安装 Tengine 执行配置命令 gcc环境"></a>1.3.安装 Tengine 执行配置命令 gcc环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf automake make</span><br></pre></td></tr></table></figure></li><li><p>若是本机上已经安装则可以忽略，主要用于编译Nginx源码</p></li></ul><h4 id="2-下载解压"><a href="#2-下载解压" class="headerlink" title="2.下载解压"></a>2.下载解压</h4><h4 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure><h4 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2.解压"></a>2.2.解压</h4><p>先创建Nginx存放路径，再进行解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginxgz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.7.8.tar.gz -C /usr/local/nginxgz</span><br></pre></td></tr></table></figure><h3 id="3-编译安装Nginx"><a href="#3-编译安装Nginx" class="headerlink" title="3.编译安装Nginx"></a>3.编译安装Nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginxgz/nginx-1.12.2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-http_stub_status_module --with-pcre</span><br></pre></td></tr></table></figure><ul><li>–with-http_ssl_module ： 支持https</li><li>–with-http_stub_status_module ： 支持nginx状态查询</li><li>–with-http_v2_module ： 支持Google发明的SPDY协议，必须有ssl的支持</li><li>–with-pcre ： 支持rewrite重写功能，必须有pcre<br>注：若是没有安装gcc则会报如下错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checking for OS</span><br><span class="line"> + Linux 2.6.32-431.el6.x86_64 x86_64</span><br><span class="line">checking for C compiler ... not found</span><br></pre></td></tr></table></figure></li></ul><p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="4-操作Nginx"><a href="#4-操作Nginx" class="headerlink" title="4.操作Nginx"></a>4.操作Nginx</h3><ul><li><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li><li><p>重启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-配置防火墙（iptables）测试"><a href="#5-配置防火墙（iptables）测试" class="headerlink" title="5.配置防火墙（iptables）测试"></a>5.配置防火墙（iptables）测试</h3><h4 id="5-1-关闭防火墙"><a href="#5-1-关闭防火墙" class="headerlink" title="5.1.关闭防火墙"></a>5.1.关闭防火墙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><h4 id="5-2-编辑配置文件"><a href="#5-2-编辑配置文件" class="headerlink" title="5.2.编辑配置文件"></a>5.2.编辑配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><h4 id="5-3-开发80端口"><a href="#5-3-开发80端口" class="headerlink" title="5.3.开发80端口"></a>5.3.开发80端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><h4 id="5-4-重启服务"><a href="#5-4-重启服务" class="headerlink" title="5.4.重启服务"></a>5.4.重启服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h4 id="测试，浏览器输入服务器地址（如：192-168-1-111）"><a href="#测试，浏览器输入服务器地址（如：192-168-1-111）" class="headerlink" title="测试，浏览器输入服务器地址（如：192.168.1.111）"></a>测试，浏览器输入服务器地址（如：192.168.1.111）</h4><p><img src="https://i.imgur.com/32msO8G.png" alt=""></p><h4 id="6-将Nginx添加到服务（service）中"><a href="#6-将Nginx添加到服务（service）中" class="headerlink" title="6.将Nginx添加到服务（service）中"></a>6.将Nginx添加到服务（service）中</h4><ul><li><p>6.1.切换到启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/init.d</span><br></pre></td></tr></table></figure></li><li><p>6.2.创建nginx文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch nginx</span><br></pre></td></tr></table></figure></li><li><p>6.3.编辑nginx文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/nginx</span><br></pre></td></tr></table></figure></li><li><p>6.4.并且添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash  </span><br><span class="line"># nginx Startup script for the Nginx HTTP Server  </span><br><span class="line">#  </span><br><span class="line"># chkconfig: - 85 15  </span><br><span class="line"># description: Nginx is a high-performance web and proxy server.  </span><br><span class="line"># It has a lot of features, but it&apos;s not for everyone.  </span><br><span class="line"># processname: nginx  </span><br><span class="line"># pidfile: /var/run/nginx.pid  </span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf  </span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx  </span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf  </span><br><span class="line">nginx_pid=/usr/local/nginx/nginx.pid  </span><br><span class="line"> </span><br><span class="line">RETVAL=0  </span><br><span class="line">prog=&quot;nginx&quot; </span><br><span class="line"> </span><br><span class="line"># Source function library.  </span><br><span class="line">. /etc/rc.d/init.d/functions  </span><br><span class="line"> </span><br><span class="line"># Source networking configuration.  </span><br><span class="line">. /etc/sysconfig/network  </span><br><span class="line"> </span><br><span class="line"># Check that networking is up.  </span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0  </span><br><span class="line"> </span><br><span class="line">[ -x $nginxd ] || exit 0  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># Start nginx daemons functions.  </span><br><span class="line">start() &#123;  </span><br><span class="line"> </span><br><span class="line">if [ -e $nginx_pid ];then </span><br><span class="line">   echo &quot;nginx already running....&quot; </span><br><span class="line">   exit 1  </span><br><span class="line">fi  </span><br><span class="line"> </span><br><span class="line">   echo -n $&quot;Starting $prog: &quot; </span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;  </span><br><span class="line">   RETVAL=$?  </span><br><span class="line">   echo  </span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx  </span><br><span class="line">   return $RETVAL  </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># Stop nginx daemons functions.  </span><br><span class="line">stop() &#123;  </span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot; </span><br><span class="line">        killproc $nginxd  </span><br><span class="line">        RETVAL=$?  </span><br><span class="line">        echo  </span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># reload nginx service functions.  </span><br><span class="line">reload() &#123;  </span><br><span class="line"> </span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot; </span><br><span class="line"> $nginxd -s reload  </span><br><span class="line">    #if your nginx version is below 0.8, please use this command: &quot;kill -HUP `cat $&#123;nginx_pid&#125;`&quot; </span><br><span class="line">    RETVAL=$?  </span><br><span class="line">    echo  </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"># See how we were called.  </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">start)  </span><br><span class="line">        start  </span><br><span class="line">        ;;  </span><br><span class="line"> </span><br><span class="line">stop)  </span><br><span class="line">        stop  </span><br><span class="line">        ;;  </span><br><span class="line"> </span><br><span class="line">reload)  </span><br><span class="line">        reload  </span><br><span class="line">        ;;  </span><br><span class="line"> </span><br><span class="line">restart)  </span><br><span class="line">        stop  </span><br><span class="line">        start  </span><br><span class="line">        ;;  </span><br><span class="line"> </span><br><span class="line">status)  </span><br><span class="line">        status $prog  </span><br><span class="line">        RETVAL=$?  </span><br><span class="line">        ;;  </span><br><span class="line">*)  </span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot; </span><br><span class="line">        exit 1  </span><br><span class="line">esac  </span><br><span class="line"> </span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure></li></ul><p>注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: nginx is a World Wide Web server. It is used to serve</span><br></pre></td></tr></table></figure></p><ul><li><p>脚本中这两个不能去除，不然不能启动，而且会报以下错误，即语法错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx 服务不支持 chkconfig</span><br></pre></td></tr></table></figure></li><li><p>chkconfig语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语　法：chkconfig [--add][--del][--list][系统服务] 或 chkconfig [--level &lt;等级代号&gt;][系统服务][on/off/reset]</span><br></pre></td></tr></table></figure></li><li><p>6.5.保存退出后，切换路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/rc.d/init.d</span><br></pre></td></tr></table></figure></li><li><p>6.6.设置权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x nginx</span><br></pre></td></tr></table></figure></li><li><p>6.7.chkconfig改变nginx运行级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/chkconfig --level 345 nginx on</span><br></pre></td></tr></table></figure></li></ul><p>到此为止：<br>任何位置都能运行   service nginx start           可选  start | stop | restart | reload | status |  help</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务器快速集成Nginx&quot;&gt;&lt;a href=&quot;#服务器快速集成Nginx&quot; class=&quot;headerlink&quot; title=&quot;服务器快速集成Nginx&quot;&gt;&lt;/a&gt;服务器快速集成Nginx&lt;/h1&gt;&lt;h3 id=&quot;1-安装依赖&quot;&gt;&lt;a href=&quot;#1-安装依赖&quot;
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 动态添加模块</title>
    <link href="https://catalpaflat.github.io/2017/08/22/nginx/Nginx%20%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/"/>
    <id>https://catalpaflat.github.io/2017/08/22/nginx/Nginx 动态添加模块/</id>
    <published>2017-08-22T05:23:42.000Z</published>
    <updated>2018-03-28T13:10:36.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-动态添加模块"><a href="#Nginx-动态添加模块" class="headerlink" title="Nginx 动态添加模块"></a>Nginx 动态添加模块</h1><p>nginx模块依赖：nginx的一些模块需要第三方支持，例如gzip模块需要zlib库，rewrite模块需要pcre库，ssl功能需要openssl库。<br>根据需求添加不同模块<br>例添加echo模块：</p><h2 id="1-下载并安装nginx"><a href="#1-下载并安装nginx" class="headerlink" title="1.下载并安装nginx"></a>1.下载并安装nginx</h2><p>详情请看：<a href="http://blog.csdn.net/dushiwodecuo/article/details/78393454" target="_blank" rel="noopener">http://blog.csdn.net/dushiwodecuo/article/details/78393454</a></p><h2 id="2-查看nginx已安装的模块"><a href="#2-查看nginx已安装的模块" class="headerlink" title="2.查看nginx已安装的模块"></a>2.查看nginx已安装的模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure><ul><li>旧版本模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-http_stub_status_module --with-pcre</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-选择与nginx版本所符合的模块版本"><a href="#3-选择与nginx版本所符合的模块版本" class="headerlink" title="3.选择与nginx版本所符合的模块版本"></a>3.选择与nginx版本所符合的模块版本</h2><p>echo：<a href="https://github.com/openresty/echo-nginx-module/tags" target="_blank" rel="noopener">https://github.com/openresty/echo-nginx-module/tags</a><br>当前nginx版本为：1.12.2，选择echo版本为0.61</p><h2 id="4-下载模块"><a href="#4-下载模块" class="headerlink" title="4.下载模块"></a>4.下载模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz</span><br></pre></td></tr></table></figure><h2 id="5-解压模块"><a href="#5-解压模块" class="headerlink" title="5.解压模块"></a>5.解压模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf v0.61.tar.gz -C /usr/local/nginxgz</span><br></pre></td></tr></table></figure><h2 id="6-为nginx添加模块"><a href="#6-为nginx添加模块" class="headerlink" title="6.为nginx添加模块"></a>6.为nginx添加模块</h2><h3 id="6-1-切换到nginx的源码目录-即解压后的目录"><a href="#6-1-切换到nginx的源码目录-即解压后的目录" class="headerlink" title="6.1.切换到nginx的源码目录(即解压后的目录)"></a>6.1.切换到nginx的源码目录(即解压后的目录)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginxgz/nginx-1.12.2</span><br></pre></td></tr></table></figure><h3 id="6-2-添加新模块"><a href="#6-2-添加新模块" class="headerlink" title="6.2.添加新模块"></a>6.2.添加新模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --add-module=/usr/local/nginxgz/echo-nginx-module-0.61 --with-http_ssl_module --with-http_v2_module --with-http_stub_status_module --with-pcre</span><br></pre></td></tr></table></figure><h2 id="7-重新编译"><a href="#7-重新编译" class="headerlink" title="7.重新编译"></a>7.重新编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h2><ul><li>Linux上的测试<h3 id="8-1-修改配置文件"><a href="#8-1-修改配置文件" class="headerlink" title="8.1.修改配置文件"></a>8.1.修改配置文件</h3><h4 id="8-1-1-修改nginx-conf，添加测试域名模块"><a href="#8-1-1-修改nginx-conf，添加测试域名模块" class="headerlink" title="8.1.1.修改nginx.conf，添加测试域名模块"></a>8.1.1.修改nginx.conf，添加测试域名模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        server_name echo.chen.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        location /&#123;</span><br><span class="line">                echo &quot;it is echo module...&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-2-修改Linux-host文件"><a href="#8-1-2-修改Linux-host文件" class="headerlink" title="8.1.2.修改Linux host文件"></a>8.1.2.修改Linux host文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;192.168.1.111 echo.chen.com&apos; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h3 id="8-2-重启nginx"><a href="#8-2-重启nginx" class="headerlink" title="8.2.重启nginx"></a>8.2.重启nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><ul><li>注：若是重启nginx之后还没能访问到，直接reboot，重启虚拟机等即可<h3 id="8-3-访问测试"><a href="#8-3-访问测试" class="headerlink" title="8.3.访问测试"></a>8.3.访问测试</h3><img src="https://i.imgur.com/so9aerf.png" alt=""></li></ul><hr><ul><li><p>Windows上浏览器测试</p><h3 id="8-1-修改配置文件-1"><a href="#8-1-修改配置文件-1" class="headerlink" title="8.1.修改配置文件"></a>8.1.修改配置文件</h3><h4 id="8-1-1-修改nginx-conf，添加测试域名模块-1"><a href="#8-1-1-修改nginx-conf，添加测试域名模块-1" class="headerlink" title="8.1.1.修改nginx.conf，添加测试域名模块"></a>8.1.1.修改nginx.conf，添加测试域名模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        server_name echo.chen.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        location /&#123;</span><br><span class="line">default_type &apos;text/html&apos;;  </span><br><span class="line">                echo &quot;it is echo module...&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>注： 如果没有这个default_type,浏览器访问则会一直下载文件而不是输出在浏览器上</p><h4 id="8-1-2-修改Windows-host文件"><a href="#8-1-2-修改Windows-host文件" class="headerlink" title="8.1.2.修改Windows host文件"></a>8.1.2.修改Windows host文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.111 echo.chen.com</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-重启nginx-1"><a href="#8-2-重启nginx-1" class="headerlink" title="8.2.重启nginx"></a>8.2.重启nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><ul><li>注：若是重启nginx之后还没能访问到，直接reboot，重启虚拟机等即可<h3 id="8-3-测试访问浏览器"><a href="#8-3-测试访问浏览器" class="headerlink" title="8.3.测试访问浏览器"></a>8.3.测试访问浏览器</h3><img src="https://i.imgur.com/5Z5ltto.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-动态添加模块&quot;&gt;&lt;a href=&quot;#Nginx-动态添加模块&quot; class=&quot;headerlink&quot; title=&quot;Nginx 动态添加模块&quot;&gt;&lt;/a&gt;Nginx 动态添加模块&lt;/h1&gt;&lt;p&gt;nginx模块依赖：nginx的一些模块需要第三方支持，例如
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 的ngx_http_core_module模块</title>
    <link href="https://catalpaflat.github.io/2017/08/20/nginx/nginx%20%E7%9A%84ngx_http_core_module%E6%A8%A1%E5%9D%97%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82/"/>
    <id>https://catalpaflat.github.io/2017/08/20/nginx/nginx 的ngx_http_core_module模块处理请求/</id>
    <published>2017-08-20T02:40:56.000Z</published>
    <updated>2018-03-28T13:06:19.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-的ngx-http-core-module模块"><a href="#Nginx-的ngx-http-core-module模块" class="headerlink" title="Nginx 的ngx_http_core_module模块"></a>Nginx 的ngx_http_core_module模块</h1><p>ngx_http_core_module模块处理请求时，会有大量的变量，这些变量可以通过访问日志来记录，也可以用于其他nginx模块接收。在对请求做策略入改写等到都会使用到一些变量。以下为ngx_http_core_module模块提供的变量总结：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$arg_PARAMETER  </span><br><span class="line">```           </span><br><span class="line">- HTTP 请求中某个参数的值，如/get?value=a.chen.com，可以用$arg_site取得a.chen.com这个值.</span><br><span class="line">```      </span><br><span class="line"> $args   </span><br><span class="line">```                    </span><br><span class="line">- HTTP 多个请求参数，请求中的完整参数。例如，在请求/get?a=1&amp;b=2 中，$args表示字符串a=1&amp;b=2.  </span><br><span class="line">```      </span><br><span class="line"> $binary_remote_addr</span><br><span class="line">```      </span><br><span class="line">- 二进制格式的客户端地址。例如：\x0B\xE0C\x0A</span><br><span class="line"></span><br><span class="line">```      </span><br><span class="line">$body_bytes_sent</span><br><span class="line">```      </span><br><span class="line">- 表示在向客户端发送的http响应中，包体部分的字节数  </span><br><span class="line">```  </span><br><span class="line">$content_length</span><br><span class="line">```  </span><br><span class="line">- 表示客户端请求头部中的Content-Length 字段的内容</span><br><span class="line">```  </span><br><span class="line">$content_type</span><br><span class="line">```  </span><br><span class="line">- 表示客户端请求头部中的Content-Type 字段的类型</span><br><span class="line">```  </span><br><span class="line">$cookie_COOKIE</span><br><span class="line">```  </span><br><span class="line">- 表示在客户端请求头部中的cookie 字段的内容  </span><br><span class="line">```  </span><br><span class="line">$document_root </span><br><span class="line">``` </span><br><span class="line">- 表示当前请求所使用的root 配置项的值  </span><br><span class="line">``` </span><br><span class="line">$uri</span><br><span class="line">```  </span><br><span class="line">- 表示当前请求的URI，不带任何参数</span><br></pre></td></tr></table></figure></p><p>$document_uri<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 与$uri 含义相同</span><br></pre></td></tr></table></figure></p><p>$request_uri<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 表示客户端发来的原始请求URI，带完整的参数。$uri和$document_uri未必是用户的原始请求，在内部重定向后可能是重定向后的URI，而$request_uri 永远不会改变，始终是客户端的原始URI.  </span><br><span class="line">```   </span><br><span class="line">$http_HEADER</span><br></pre></td></tr></table></figure></p><ul><li><p>表示当前 HTTP请求中相应头部的值。HEADER名称全小写。例如，示请求中 Host头部对应的值 用 $http_host表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$host</span><br></pre></td></tr></table></figure></li><li><p>表示客户端请求头部中的Host字段。如果Host字段不存在，则以实际处理的server（虚拟主机）名称代替。如果Host字段中带有端口，如IP:PORT，那么$host是去掉端口的，它的值为IP。$host 是全小写的。这些特性与http_HEADER中的http_host不同，http_host只取出Host头部对应的值。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hostname</span><br></pre></td></tr></table></figure></li><li><p>表示 Nginx所在机器的名称，与 gethostbyname调用返回的值相同   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sent_http_HEADER</span><br></pre></td></tr></table></figure></li><li><p>表示返回客户端的 HTTP响应中相应头部的值。HEADER名称全小写。例如，用 $sent_http_content_type表示响应中 Content-Type头部对应的值   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$is_args</span><br></pre></td></tr></table></figure></li><li><p>表示请求中的 URI 是否带参数，如果带参数，$is_args值为 ?，如果不带参数，则是空字符串,可以用于条件判断  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$limit_rate</span><br></pre></td></tr></table></figure></li><li><p>表示当前连接的限速是多少，0表示无限速   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nginx_version</span><br></pre></td></tr></table></figure></li><li><p>表示当前 Nginx的版本号   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query_string</span><br></pre></td></tr></table></figure></li><li><p>请求 URI中的参数，与 $args相同，然而 $query_string是只读的不会改变   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$remote_addr</span><br></pre></td></tr></table></figure></li><li><p>表示客户端的地址   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$remote_port</span><br></pre></td></tr></table></figure></li><li><p>表示客户端连接使用的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$remote_user</span><br></pre></td></tr></table></figure></li><li><p>表示使用 Auth Basic Module时定义的用户名   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$request_filename</span><br></pre></td></tr></table></figure></li><li><p>表示用户请求中的 URI 经过 root或 alias转换后的文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$request_body</span><br></pre></td></tr></table></figure></li><li><p>表示 HTTP请求中的包体，该参数只在 proxy_pass 或 fastcgi_pass 中有意义   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$request_body_file</span><br></pre></td></tr></table></figure></li><li><p>表示 HTTP请求中的包体存储的临时文件名   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$request_completion</span><br></pre></td></tr></table></figure></li><li><p>当请求已经全部完成时，其值为 “ok”。若没有完成，就要返回客户端，则其值为空字符串；或者在断点续传等情况下使用 HTTP range 访问的并不是文件的最后一块，那么其值也是空字符串。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$request_method</span><br></pre></td></tr></table></figure></li><li><p>表示 HTTP 请求的方法名，如 GET、PUT、POST等   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scheme</span><br></pre></td></tr></table></figure></li><li><p>表示 HTTP scheme，如在请求 <a href="https://nginx.com/中表示" target="_blank" rel="noopener">https://nginx.com/中表示</a> https</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$server_addr</span><br></pre></td></tr></table></figure></li><li><p>表示服务器地址   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$server_name</span><br></pre></td></tr></table></figure></li><li><p>表示服务器名称   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$server_port</span><br></pre></td></tr></table></figure></li><li><p>表示服务器端口   </p><pre><code>$server_protocol</code></pre></li><li>表示服务器向客户端发送响应的协议，如 HTTP/1.1或 HTTP/1.0  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-的ngx-http-core-module模块&quot;&gt;&lt;a href=&quot;#Nginx-的ngx-http-core-module模块&quot; class=&quot;headerlink&quot; title=&quot;Nginx 的ngx_http_core_module模块&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://catalpaflat.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>JavaEE 微信境外支付</title>
    <link href="https://catalpaflat.github.io/2017/08/05/%E6%94%AF%E4%BB%98/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/JavaEE%20%E5%BE%AE%E4%BF%A1%E5%A2%83%E5%A4%96%E6%94%AF%E4%BB%98/"/>
    <id>https://catalpaflat.github.io/2017/08/05/支付/微信支付/JavaEE 微信境外支付/</id>
    <published>2017-08-05T02:33:12.000Z</published>
    <updated>2018-03-30T02:54:57.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaEE-微信境外支付"><a href="#JavaEE-微信境外支付" class="headerlink" title="JavaEE 微信境外支付"></a>JavaEE 微信境外支付</h1><blockquote><p><a href="https://pay.weixin.qq.com/wiki/doc/api/external/index.html" target="_blank" rel="noopener">API文档</a></p><p>境外分为两种：   </p><ul><li>普通商户版</li><li>服务商版</li></ul><p>普通商户版：   </p><p>1.支付方式:  </p><ul><li>刷卡支付</li><li>公众号支付</li><li>扫码支付</li><li>APP支付</li></ul><p>2.报关接口：<br>用于商户提交海关需要的订单附近信息</p><p>服务商版包括的支付方式有：  </p><ul><li>刷卡支付</li><li>公众号支付</li><li>扫码支付</li></ul></blockquote><h2 id="1-普通商户版"><a href="#1-普通商户版" class="headerlink" title="1. 普通商户版"></a>1. 普通商户版</h2><h3 id="1-1-刷卡支付"><a href="#1-1-刷卡支付" class="headerlink" title="1.1 刷卡支付"></a>1.1 刷卡支付</h3><blockquote><p><a href="https://pay.weixin.qq.com/wiki/doc/api/external/micropay.php?chapter=9_10&amp;index=1" target="_blank" rel="noopener">详情API文档</a>.   </p><p><strong>应用场景:</strong><br>收银员使用扫码设备读取微信用户刷卡授权码以后，二维码或条码信息传送至商户收银台，由商户收银台或者商户后台调用该接口发起支付。    </p></blockquote><blockquote><p><strong>⚠️提醒1：</strong>提交支付请求后微信会同步返回支付结果。当返回结果为“系统错误”时，商户系统等待5秒后调用【查询订单API】，查询支付实际交易结果；当返回结果为“USERPAYING”时，商户系统可设置间隔时间(建议10秒)重新查询支付结果，直到支付成功或超时(建议30秒)；   </p><p><strong>⚠️提醒2：</strong>在调用查询接口返回后，如果交易状况不明晰，请调用【撤销订单API】，此时如果交易失败则关闭订单，该单不能再支付成功；如果交易成功，则将扣款退回到用户账户。当撤销无返回或错误时，请再次调用。注意：请勿扣款后立即调用【撤销订单API】,建议至少15秒后再调用。撤销订单API需要双向证书。</p></blockquote><h4 id="1-1-1-接口url："><a href="#1-1-1-接口url：" class="headerlink" title="1.1.1 接口url："></a>1.1.1 接口url：</h4><ul><li><a href="https://apihk.mch.weixin.qq.com/pay/micropay" target="_blank" rel="noopener">https://apihk.mch.weixin.qq.com/pay/micropay</a>    （建议接入点：东南亚）</li><li><a href="https://apius.mch.weixin.qq.com/pay/micropay" target="_blank" rel="noopener">https://apius.mch.weixin.qq.com/pay/micropay</a>    （建议接入点：其它）</li><li><a href="https://api.mch.weixin.qq.com/pay/micropay" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/pay/micropay</a>        （建议接入点：中国国内）</li></ul><h4 id="1-1-2-与境内对比参数"><a href="#1-1-2-与境内对比参数" class="headerlink" title="1.1.2 与境内对比参数"></a>1.1.2 与境内对比参数</h4><p>除了以下参数，其他都和国内一致。</p><table><thead><tr><th>名称</th><th>变量名</th><th>必填</th><th>类型</th><th>示例值</th><th>描述</th></tr></thead><tbody><tr><td>版本号</td><td>version</td><td>否</td><td>String(32)</td><td>1.0</td><td>固定值 1.0</td></tr><tr><td>商品详情</td><td>detail</td><td>否</td><td>String(6000)</td><td></td><td>商品详细列表，使用Json格式，传输签名前请务必使用CDATA标签将JSON文本串保护起来。</td></tr></tbody></table><ol><li>商品详情类型</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"goods_detail"</span>:[</span><br><span class="line">&#123; </span><br><span class="line"><span class="attr">"goods_name"</span>:<span class="string">"iPhone6s 16G"</span>,</span><br><span class="line"><span class="attr">"quantity"</span>:<span class="number">1</span>, </span><br><span class="line">&#125;,</span><br><span class="line">&#123; </span><br><span class="line"><span class="attr">"goods_name"</span>:<span class="string">"iPhone6s 32G"</span>,</span><br><span class="line"><span class="attr">"quantity"</span>:<span class="number">1</span>, </span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>商品详情描述</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goods_detail</span><br><span class="line">└ goods_name String 必填 256 商品名称</span><br><span class="line">└ quantity Int 必填4 商品数量</span><br></pre></td></tr></table></figure><h4 id="1-1-3-支付方式："><a href="#1-1-3-支付方式：" class="headerlink" title="1.1.3 支付方式："></a>1.1.3 支付方式：</h4><ol><li>免密支付流程  </li><li>验密支付流程   </li></ol><h3 id="1-2-公众号支付"><a href="#1-2-公众号支付" class="headerlink" title="1.2 公众号支付"></a>1.2 公众号支付</h3><blockquote><p><strong>注意：</strong>商户也可以把商品网页的链接生成二维码，用户扫一扫打开后即可完成购买支付。   </p><p>交互细节：   </p><p>以下是支付场景的交互细节，请认真阅读，设计商户页面的逻辑：  </p><ul><li>（1）用户打开商户网页选购商品，发起支付，在网页通过JavaScript调用getBrandWCPayRequest接口，发起微信支付请求，用户进入支付流程。</li><li>（2）用户成功支付点击完成按钮后，商户的前端会收到JavaScript的返回值。商户可直接跳转到支付成功的静态页面进行展示。</li><li>（3）商户后台收到来自微信开放平台的支付成功回调通知，标志该笔订单支付成功。</li></ul><p><strong>注：</strong>（2）和（3）的触发不保证遵循严格的时序。JS API返回值作为触发商户网页跳转的标志，但商户后台应该只在收到微信后台的支付成功回调通知后，才做真正的支付成功的处理。</p></blockquote><h4 id="1-2-1-接口url："><a href="#1-2-1-接口url：" class="headerlink" title="1.2.1 接口url："></a>1.2.1 接口url：</h4><ul><li><a href="https://apihk.mch.weixin.qq.com/pay/unifiedorder" target="_blank" rel="noopener">https://apihk.mch.weixin.qq.com/pay/unifiedorder</a>    （建议接入点：东南亚）</li><li><a href="https://apius.mch.weixin.qq.com/pay/unifiedorder" target="_blank" rel="noopener">https://apius.mch.weixin.qq.com/pay/unifiedorder</a>    （建议接入点：其它）</li><li><a href="https://api.mch.weixin.qq.com/pay/unifiedorder" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/pay/unifiedorder</a>        （建议接入点：中国国内）</li></ul><p><strong>注：</strong>商户可根据实际请求情况选择最优域名进行访问，建议在接入时做好兼容，当访问其中一个域名出现异常时，可自动切换为其他域名。</p><h4 id="1-2-2-与境内对比参数"><a href="#1-2-2-与境内对比参数" class="headerlink" title="1.2.2 与境内对比参数"></a>1.2.2 与境内对比参数</h4><p>和刷卡支付一样的参数区别。</p><h3 id="1-3-扫码支付"><a href="#1-3-扫码支付" class="headerlink" title="1.3 扫码支付"></a>1.3 扫码支付</h3><p>几乎和公众号支付相同</p><h3 id="1-4-APP支付"><a href="#1-4-APP支付" class="headerlink" title="1.4 APP支付"></a>1.4 APP支付</h3><blockquote><p>商户系统先调用该接口在微信支付服务后台生成预支付交易单，返回正确的预支付交易回话标识后再在APP里面调起支付。</p></blockquote><p>除了请求参数“版本号” 和“商品详情” 不一样，其他都和境内一致。</p><h3 id="1-5-报关接口"><a href="#1-5-报关接口" class="headerlink" title="1.5 报关接口"></a>1.5 报关接口</h3><blockquote><p>用于商户提交海关需要的订单附件信息。报关接口只支持一个月内的支付订单进行报关申请。<br>以下为财付通的海关备案信息，一般海关会提供，如果没有请参考下表：<br>财付通海关备案名称：财付通支付科技有限公司<br>财付通10位海关注册编码：440316T004</p></blockquote><h4 id="1-5-1-订单附加信息提交接口"><a href="#1-5-1-订单附加信息提交接口" class="headerlink" title="1.5.1 订单附加信息提交接口"></a>1.5.1 订单附加信息提交接口</h4><blockquote><p><a href="https://pay.weixin.qq.com/wiki/doc/api/external/declarecustom.php?chapter=18_1" target="_blank" rel="noopener">详情API</a></p></blockquote><h5 id="1-5-1-1-url"><a href="#1-5-1-1-url" class="headerlink" title="1.5.1.1 url"></a>1.5.1.1 url</h5><p>URL地址：<a href="https://api.mch.weixin.qq.com/cgi-bin/mch/customs/customdeclareorder" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/cgi-bin/mch/customs/customdeclareorder</a></p><p><strong>重点注意：请求接口前请先在以下页面提交您的海关信息，所有你需要报关的海关信息都需要提交，且信息真实有效：<a href="https://pay.weixin.qq.com/index.php/extend/customs" target="_blank" rel="noopener">https://pay.weixin.qq.com/index.php/extend/customs</a></strong></p><h4 id="1-5-2-订单附加信息查询接口"><a href="#1-5-2-订单附加信息查询接口" class="headerlink" title="1.5.2 订单附加信息查询接口"></a>1.5.2 订单附加信息查询接口</h4><blockquote><p>商户通过订单号查询提交的订单附加信息。如果是微信收集的实名信息，查询接口不返回实名信息内容.   </p><p><a href="https://pay.weixin.qq.com/wiki/doc/api/external/declarecustom.php?chapter=18_2" target="_blank" rel="noopener">详情API</a></p></blockquote><h2 id="2-服务商版"><a href="#2-服务商版" class="headerlink" title="2. 服务商版"></a>2. 服务商版</h2><blockquote><p><a href="https://pay.weixin.qq.com/wiki/doc/api/external/micropay_sl.php?chapter=9_10&amp;index=1" target="_blank" rel="noopener">详情API文档</a></p></blockquote><h3 id="2-1-刷卡支付"><a href="#2-1-刷卡支付" class="headerlink" title="2.1 刷卡支付"></a>2.1 刷卡支付</h3><h4 id="2-1-1-url"><a href="#2-1-1-url" class="headerlink" title="2.1.1 url"></a>2.1.1 url</h4><p><a href="https://api.mch.weixin.qq.com/pay/micropay" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/pay/micropay</a></p><h4 id="2-1-1-参数区别"><a href="#2-1-1-参数区别" class="headerlink" title="2.1.1 参数区别"></a>2.1.1 参数区别</h4><p>和普通商户版刷卡支付一样的参数区别。</p><h3 id="2-2-公众号支付"><a href="#2-2-公众号支付" class="headerlink" title="2.2 公众号支付"></a>2.2 公众号支付</h3><blockquote><p><a href="https://pay.weixin.qq.com/wiki/doc/api/external/jsapi_sl.php?chapter=9_1" target="_blank" rel="noopener">详情API文档</a></p></blockquote><h4 id="2-2-1-url"><a href="#2-2-1-url" class="headerlink" title="2.2.1 url"></a>2.2.1 url</h4><p><a href="https://api.mch.weixin.qq.com/pay/unifiedorder" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/pay/unifiedorder</a></p><h4 id="2-2-2-参数区别："><a href="#2-2-2-参数区别：" class="headerlink" title="2.2.2 参数区别："></a>2.2.2 参数区别：</h4><table><thead><tr><th>名称</th><th>变量名</th><th>必填</th><th>类型</th><th>示例值</th><th>描述</th></tr></thead><tbody><tr><td>商品ID</td><td>product_id</td><td>否</td><td>String(32)</td><td>12235413214070356458058</td><td>trade_type=NATIVE，此参数必传。此id为二维码中包含的商品ID，商户自行定义。</td></tr><tr><td>用户标识</td><td>openid</td><td>否</td><td>String(128)</td><td>oUpF8uMuAJO_M2pxb1Q9zNjWeS6o</td><td>trade_type=JSAPI，此参数必传，用户在主商户appid下的唯一标识。openid和sub_openid可以选传其中之一，如果选择传sub_openid,则必须传sub_appid。下单前需要调用【网页授权获取用户信息】接口获取到用户的Openid。</td></tr><tr><td>用户子标识</td><td>sub_openid</td><td>否</td><td>String(128)</td><td>oUpF8uMuAJO_M2pxb1Q9zNjWeS6o</td><td>trade_type=JSAPI，此参数必传，用户在子商户appid下的唯一标识。openid和sub_openid可以选传其中之一，如果选择传sub_openid,则必须传sub_appid。下单前需要调用【网页授权获取用户信息】接口获取到用户的Openid。</td></tr></tbody></table><h3 id="2-3-扫码支付"><a href="#2-3-扫码支付" class="headerlink" title="2.3 扫码支付"></a>2.3 扫码支付</h3><blockquote><p><a href="https://pay.weixin.qq.com/wiki/doc/api/external/native_sl.php?chapter=9_1" target="_blank" rel="noopener">详情API文档</a></p></blockquote><p>和公众号支付一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaEE-微信境外支付&quot;&gt;&lt;a href=&quot;#JavaEE-微信境外支付&quot; class=&quot;headerlink&quot; title=&quot;JavaEE 微信境外支付&quot;&gt;&lt;/a&gt;JavaEE 微信境外支付&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="支付" scheme="https://catalpaflat.github.io/categories/%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="支付" scheme="https://catalpaflat.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaEE 支付宝支付</title>
    <link href="https://catalpaflat.github.io/2017/08/04/%E6%94%AF%E4%BB%98/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/JavaEE%20%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/"/>
    <id>https://catalpaflat.github.io/2017/08/04/支付/支付宝支付/JavaEE 支付宝支付/</id>
    <published>2017-08-04T11:33:12.000Z</published>
    <updated>2018-03-30T12:10:54.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaEE-支付宝支付"><a href="#JavaEE-支付宝支付" class="headerlink" title="JavaEE 支付宝支付"></a>JavaEE 支付宝支付</h1><blockquote><p><a href="https://docs.open.alipay.com/api_1/alipay.trade.app.pay/" target="_blank" rel="noopener">开发文档大全</a>   </p><p>支付宝已经更新添封装好的签名方法,可以在自己的项目中直接调用进行签名,减少了自己手动签名产生的问题,主要是在进行方法调用时注意传参的要求,尤其是公钥使用的是支付宝的公钥,而不是APP的公钥。   </p><p>支付宝支付使用SDK进行对接API，会比微信好很多，已经封装好了，不同请求对象对应不同响应对象。</p></blockquote><h2 id="1-支付宝—双对称加密"><a href="#1-支付宝—双对称加密" class="headerlink" title="1. 支付宝—双对称加密"></a>1. 支付宝—双对称加密</h2><p><strong>支付宝与微信的不同之处：</strong>   </p><ol><li>微信是通过xml以及签名进行数据保护</li><li>支付宝是通过双对称加密进行数据保护</li></ol><p><strong>支付宝双对称加密：</strong>   </p><ol><li>用户先使用 <a href="https://docs.open.alipay.com/291/106097" target="_blank" rel="noopener">RSA密钥工具</a>  生成自身一对用户的对称秘钥（公钥和秘钥）</li><li>将公钥上传到支付宝（在创建应用时便会让用户提供）</li><li>支付宝会根据上传到公钥生成一对 支付宝的对称秘钥（公钥和秘钥）</li></ol><p><strong>支付宝双对称加密使用方式：</strong>   </p><ol><li>用户加签 的时候是用 用户的私钥</li><li>用户解密 的时候是用 支付宝的公钥  </li><li>支付宝加签 的时候是用 支付宝的私钥</li><li>支付宝解密 的时候是用 用户的公钥</li></ol><p><strong>详情图解:</strong>  </p><p><img src="img/支付宝双对称加密.png" alt="支付宝双对称加密"></p><h2 id="2-支付宝常用API接口"><a href="#2-支付宝常用API接口" class="headerlink" title="2. 支付宝常用API接口"></a>2. 支付宝常用API接口</h2><p>支付API：   </p><ul><li>app支付接口2.0</li><li>手机网站支付接口2.0</li><li>统一收单交易退款查询</li><li>统一收单交易结算接口</li><li>统一收单交易关闭接口</li><li>统一收单交易撤销接口</li><li>统一收单交易退款接口</li><li>统一收单线下交易预创建</li><li>统一收单交易创建接口</li><li>统一收单交易支付接口</li><li>统一收单线下交易查询</li></ul><h2 id="3-Java-Instance"><a href="#3-Java-Instance" class="headerlink" title="3. Java Instance"></a>3. Java Instance</h2><p><strong>普通调用示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化客户端</span></span><br><span class="line">AlipayClient alipayClient = <span class="keyword">new</span> DefaultAlipayClient(<span class="string">"https://openapi.alipay.com/gateway.do"</span>, APP_ID, APP_PRIVATE_KEY, <span class="string">"json"</span>, CHARSET, ALIPAY_PUBLIC_KEY, <span class="string">"RSA2"</span>);</span><br><span class="line"><span class="comment">//实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称：alipay.open.public.template.message.industry.modify </span></span><br><span class="line">AlipayOpenPublicTemplateMessageIndustryModifyRequest request = <span class="keyword">new</span> AlipayOpenPublicTemplateMessageIndustryModifyRequest();</span><br><span class="line"><span class="comment">//SDK已经封装掉了公共参数，这里只需要传入业务参数</span></span><br><span class="line"><span class="comment">//此次只是参数展示，未进行字符串转义，实际情况下请转义</span></span><br><span class="line">request.setBizContent(<span class="string">"  &#123;"</span> +</span><br><span class="line"><span class="string">"    \"primary_industry_name\":\"IT科技/IT软件与服务\","</span> +</span><br><span class="line"><span class="string">"    \"primary_industry_code\":\"10001/20102\","</span> +</span><br><span class="line"><span class="string">"    \"secondary_industry_code\":\"10001/20102\","</span> +</span><br><span class="line"><span class="string">"    \"secondary_industry_name\":\"IT科技/IT软件与服务\""</span> +</span><br><span class="line"><span class="string">" &#125;"</span>);</span><br><span class="line">AlipayOpenPublicTemplateMessageIndustryModifyResponse response = alipayClient.execute(request); </span><br><span class="line"><span class="comment">//调用成功，则处理业务逻辑</span></span><br><span class="line"><span class="keyword">if</span>(response.isSuccess())&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>app支付接口2.0</strong> </p><pre><code class="java">AlipayClient alipayClient = <span class="keyword">new</span> DefaultAlipayClient(<span class="string">"https://openapi.alipay.com/gateway.do"</span>,<span class="string">"app_id"</span>,<span class="string">"your private_key"</span>,<span class="string">"json"</span>,<span class="string">"GBK"</span>,<span class="string">"alipay_public_key"</span>,<span class="string">"RSA2"</span>);AlipayTradeAppPayRequest request = <span class="keyword">new</span> AlipayTradeAppPayRequest();request.setBizContent(<span class="string">"{"</span> +<span class="string">"\"timeout_express\":\"90m\","</span> +<span class="string">"\"total_amount\":\"9.00\","</span> +<span class="string">"\"seller_id\":\"2088102147948060\","</span> +<span class="string">"\"product_code\":\"QUICK_MSECURITY_PAY\","</span> +<span class="string">"\"body\":\"Iphone6 16G\","</span> +<span class="string">"\"subject\":\"大乐透\","</span> +<span class="string">"\"out_trade_no\":\"70501111111S001111119\","</span> +<span class="string">"\"time_expire\":\"2016-12-31 10:05\","</span> +<span class="string">"\"goods_type\":\"0\","</span> +<span class="string">"\"promo_params\":\"{\\\"storeIdType\\\":\\\"1\\\"}\","</span> +<span class="string">"\"passback_params\":\"merchantBizType%3d3C%26merchantBizNo%3d2016010101111\","</span> +<span class="string">"\"royalty_info\":{"</span> +<span class="string">"\"royalty_type\":\"ROYALTY\","</span> +<span class="string">"        \"royalty_detail_infos\":[{"</span> +<span class="string">"          \"serial_no\":1,"</span> +<span class="string">"\"trans_in_type\":\"userId\","</span> +<span class="string">"\"batch_no\":\"123\","</span> +<span class="string">"\"out_relation_id\":\"20131124001\","</span> +<span class="string">"\"trans_out_type\":\"userId\","</span> +<span class="string">"\"trans_out\":\"2088101126765726\","</span> +<span class="string">"\"trans_in\":\"2088101126708402\","</span> +<span class="string">"\"amount\":0.1,"</span> +<span class="string">"\"desc\":\"分账测试1\","</span> +<span class="string">"\"amount_percentage\":\"100\""</span> +<span class="string">"          }]"</span> +<span class="string">"    },"</span> +<span class="string">"\"extend_params\":{"</span> +<span class="string">"\"sys_service_provider_id\":\"2088511833207846\","</span> +<span class="string">"\"hb_fq_num\":\"3\","</span> +<span class="string">"\"hb_fq_seller_percent\":\"100\","</span> +<span class="string">"\"industry_reflux_info\":\"{\\\\\\\"scene_code\\\\\\\":\\\\\\\"metro_tradeorder\\\\\\\",\\\\\\\"channel\\\\\\\":\\\\\\\"xxxx\\\\\\\",\\\\\\\"scene_data\\\\\\\":{\\\\\\\"asset_name\\\\\\\":\\\\\\\"ALIPAY\\\\\\\"}}\","</span> +<span class="string">"\"card_type\":\"S0JP0000\""</span> +<span class="string">"    },"</span> +<span class="string">"\"sub_merchant\":{"</span> +<span class="string">"\"merchant_id\":\"19023454\","</span> +<span class="string">"\"merchant_type\":\"alipay: 支付宝分配的间连商户编号, merchant: 商户端的间连商户编号\""</span> +<span class="string">"    },"</span> +<span class="string">"\"enable_pay_channels\":\"pcredit,moneyFund,debitCardExpress\","</span> +<span class="string">"\"store_id\":\"NJ_001\","</span> +<span class="string">"\"specified_channel\":\"pcredit\","</span> +<span class="string">"\"disable_pay_channels\":\"pcredit,moneyFund,debitCardExpress\","</span> +<span class="string">"\"settle_info\":{"</span> +<span class="string">"        \"settle_detail_infos\":[{"</span> +<span class="string">"          \"trans_in_type\":\"cardSerialNo\","</span> +<span class="string">"\"trans_in\":\"A0001\","</span> +<span class="string">"\"summary_dimension\":\"A0001\","</span> +<span class="string">"\"amount\":0.1"</span> +<span class="string">"          }]"</span> +<span class="string">"    },"</span> +<span class="string">"\"invoice_info\":{"</span> +<span class="string">"\"key_info\":{"</span> +<span class="string">"\"is_support_invoice\":true,"</span> +<span class="string">"\"invoice_merchant_name\":\"ABC|003\","</span> +<span class="string">"\"tax_num\":\"1464888883494\""</span> +<span class="string">"      },"</span> +<span class="string">"\"details\":\"[{\\\"code\\\":\\\"100294400\\\",\\\"name\\\":\\\"服饰\\\",\\\"num\\\":\\\"2\\\",\\\"sumPrice\\\":\\\"200.00\\\",\\\"taxRate\\\":\\\"6%\\\"}]\""</span> +<span class="string">"    },"</span> +<span class="string">"\"ext_user_info\":{"</span> +<span class="string">"\"name\":\"李明\","</span> +<span class="string">"\"mobile\":\"16587658765\","</span> +<span class="string">"\"cert_type\":\"IDENTITY_CARD\","</span> +<span class="string">"\"cert_no\":\"362334768769238881\","</span> +<span class="string">"\"min_age\":\"18\","</span> +<span class="string">"\"fix_buyer\":\"F\","</span> +<span class="string">"\"need_check_info\":\"F\""</span> +<span class="string">"    },"</span> +<span class="string">"\"business_params\":\"{\\\"data\\\":\\\"123\\\"}\""</span> +<span class="string">"  }"</span>);AlipayTradeAppPayResponse response = alipayClient.pageExecute(request);<span class="keyword">if</span>(response.isSuccess()){System.out.println(<span class="string">"调用成功"</span>);} <span class="keyword">else</span> {System.out.println(<span class="string">"调用失败"</span>);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaEE-支付宝支付&quot;&gt;&lt;a href=&quot;#JavaEE-支付宝支付&quot; class=&quot;headerlink&quot; title=&quot;JavaEE 支付宝支付&quot;&gt;&lt;/a&gt;JavaEE 支付宝支付&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="支付" scheme="https://catalpaflat.github.io/categories/%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="支付宝支付" scheme="https://catalpaflat.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaEE 微信支付</title>
    <link href="https://catalpaflat.github.io/2017/08/04/%E6%94%AF%E4%BB%98/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/JavaEE%20%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
    <id>https://catalpaflat.github.io/2017/08/04/支付/微信支付/JavaEE 微信支付/</id>
    <published>2017-08-04T11:33:12.000Z</published>
    <updated>2018-03-30T02:55:24.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaEE-微信支付"><a href="#JavaEE-微信支付" class="headerlink" title="JavaEE 微信支付"></a>JavaEE 微信支付</h1><blockquote><p>微信境内支付包括：  </p><ul><li>App支付</li><li>公众号支付</li><li>小程序支付</li><li>H5 支付</li><li>扫码支付</li><li>刷卡支付</li></ul><p>除刷卡支付场景以外，商户系统先调用该接口在微信支付服务后台生成预支付交易单，返回正确的预支付交易回话标识后再按扫码、JSAPI、APP等不同场景生成交易串调起支付。</p><p><a href="https://pay.weixin.qq.com/wiki/doc/api/index.html" target="_blank" rel="noopener">API 文档</a></p></blockquote><h2 id="1-常用API-列表"><a href="#1-常用API-列表" class="headerlink" title="1. 常用API 列表"></a>1. 常用API 列表</h2><ol><li>统一下单（提交刷卡支付）</li><li>查询订单</li><li>关闭订单</li><li>申请退款</li><li>查询退款</li><li>下载对账账单</li><li>下载资金账单</li><li>支付结果通知</li><li>退款结果通知</li></ol><h2 id="2-微信支付接口请求大致流程"><a href="#2-微信支付接口请求大致流程" class="headerlink" title="2. 微信支付接口请求大致流程"></a>2. 微信支付接口请求大致流程</h2><ol><li>封装请求参数</li><li>将请求参数进行sort()</li><li>对排序好的参数进行trim()</li><li>将参数拼接为正确顺序的uri并加入key（秘钥）到最后</li><li>将uri进行签名得到sign</li><li>将参数以及sign（排除秘钥）按顺序转为xml</li><li>请求对应接口（统一下单等）</li><li>响应时也是xml格式</li><li>转换xml为Map格式</li><li>校验returnCode和resultCode</li></ol><h2 id="3-常用API中的区别点"><a href="#3-常用API中的区别点" class="headerlink" title="3. 常用API中的区别点"></a>3. 常用API中的区别点</h2><h3 id="3-1-刷卡支付"><a href="#3-1-刷卡支付" class="headerlink" title="3.1 刷卡支付"></a>3.1 刷卡支付</h3><p>1.下单非统一下单，而是提交刷卡支付，即请求的url和其他几种都不同。</p><ul><li>刷卡请求url：<a href="https://api.mch.weixin.qq.com/pay/micropay" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/pay/micropay</a></li><li>其他统一下单url：<a href="https://api.mch.weixin.qq.com/pay/unifiedorde" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/pay/unifiedorde</a></li></ul><p>2.提交刷卡支付参数中不能携带参数有以下：（其他类型支付均可）。 </p><table><thead><tr><th>名称</th><th>变量名</th><th>必填</th><th>类型</th><th>示例值</th><th>描述</th></tr></thead><tbody><tr><td>交易类型</td><td>trade_type</td><td>是</td><td>String(16)</td><td>JSAPI</td><td>JSAPI 公众号支付 NATIVE 扫码支付 APP APP支付</td></tr><tr><td>用户标识</td><td>openid</td><td>否</td><td>String(128)</td><td>oUpF8uMuAJO_M2pxb1Q9zNjWeS6o</td><td>trade_type=JSAPI时（即公众号支付），此参数必传，此参数为微信用户在商户对应appid下的唯一标识。openid如何获取，可参考【获取openid】。企业号请使用【企业号OAuth2.0接口】获取企业号内成员userid，再调用【企业号userid转openid接口】进行转换</td></tr><tr><td>通知地址</td><td>notify_url</td><td>是</td><td>String(256)</td><td><a href="http://www.weixin.qq.com/wxpay/pay.php" target="_blank" rel="noopener">http://www.weixin.qq.com/wxpay/pay.php</a></td><td>异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。</td></tr></tbody></table><h3 id="3-2-授权码"><a href="#3-2-授权码" class="headerlink" title="3.2 授权码"></a>3.2 授权码</h3><p>提交刷卡支接口需要：auth_code.   </p><table><thead><tr><th>名称</th><th>变量名</th><th>必填</th><th>类型</th><th>示例值</th><th>描述</th></tr></thead><tbody><tr><td>授权码</td><td>auth_code</td><td>是</td><td>String(128)</td><td>120061098828009406</td><td>扫码支付授权码，设备读取用户微信中的条码或者二维码信息（注：用户刷卡条形码规则：18位纯数字，以10、11、12、13、14、15开头）</td></tr></tbody></table><h3 id="3-3-H5支付"><a href="#3-3-H5支付" class="headerlink" title="3.3 H5支付"></a>3.3 H5支付</h3><p><strong>注⚠️：提醒：H5支付不建议在APP端使用，如需要在APP中使用微信支付，请接APP支付</strong></p><table><thead><tr><th>名称</th><th>变量名</th><th>必填</th><th>类型</th><th>示例值</th><th>描述</th></tr></thead><tbody><tr><td>场景信息</td><td>scene_info</td><td>是</td><td>String(256)</td><td></td></tr></tbody></table><ol><li>示例值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//IOS移动应用</span><br><span class="line">&#123;&quot;h5_info&quot;: &#123;&quot;type&quot;:&quot;IOS&quot;,&quot;app_name&quot;: &quot;王者荣耀&quot;,&quot;bundle_id&quot;: &quot;com.tencent.wzryIOS&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">//安卓移动应用</span><br><span class="line">&#123;&quot;h5_info&quot;: &#123;&quot;type&quot;:&quot;Android&quot;,&quot;app_name&quot;: &quot;王者荣耀&quot;,&quot;package_name&quot;: &quot;com.tencent.tmgp.sgame&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">//WAP网站应用</span><br><span class="line">&#123;&quot;h5_info&quot;: &#123;&quot;type&quot;:&quot;Wap&quot;,&quot;wap_url&quot;: &quot;https://pay.qq.com&quot;,&quot;wap_name&quot;: &quot;腾讯充值&quot;&#125;&#125;该字段用于上报支付的场景信息,针对H5支付有以下三种场景,请根据对应场景上报,H5支付不建议在APP端使用，针对场景1，2请接入APP支付，不然可能会出现兼容性问题</span><br></pre></td></tr></table></figure><ol><li>描述.  </li></ol><p>1，IOS移动应用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"h5_info"</span>: //h5支付固定传<span class="string">"h5_info"</span></span><br><span class="line">    &#123;"type": "",  //场景类型</span><br><span class="line">     "app_name": "",  //应用名</span><br><span class="line">     "bundle_id": ""  //bundle_id</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2，安卓移动应用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"h5_info"</span>: //h5支付固定传<span class="string">"h5_info"</span></span><br><span class="line">    &#123;"type": "",  //场景类型</span><br><span class="line">     "app_name": "",  //应用名</span><br><span class="line">     "package_name": ""  //包名</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，WAP网站应用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"h5_info"</span>: //h5支付固定传<span class="string">"h5_info"</span></span><br><span class="line">   &#123;"type": "",  //场景类型</span><br><span class="line">    "wap_url": "",//WAP网站URL地址</span><br><span class="line">    "wap_name": ""  //WAP 网站名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-微信境外支付"><a href="#4-微信境外支付" class="headerlink" title="4. 微信境外支付"></a>4. 微信境外支付</h2><p><a href="JavaEE 微信境外支付.md">JavaEE 微信境外支付</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaEE-微信支付&quot;&gt;&lt;a href=&quot;#JavaEE-微信支付&quot; class=&quot;headerlink&quot; title=&quot;JavaEE 微信支付&quot;&gt;&lt;/a&gt;JavaEE 微信支付&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;微信境内支付包括：  &lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="支付" scheme="https://catalpaflat.github.io/categories/%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="支付" scheme="https://catalpaflat.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>分布式之消息中间件</title>
    <link href="https://catalpaflat.github.io/2017/07/23/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://catalpaflat.github.io/2017/07/23/消息队列/消息中间件/</id>
    <published>2017-07-23T07:46:12.000Z</published>
    <updated>2018-03-28T13:03:30.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式之消息中间件"><a href="#分布式之消息中间件" class="headerlink" title="分布式之消息中间件"></a>分布式之消息中间件</h1><blockquote><p>目录</p><ul><li><a href="#1">1.消息中间件概述</a></li><li><a href="#2">2.消息中间件使用场景</a></li><li><a href="#3">3.消息中间件原理</a></li><li><a href="#4">4.消息中间件传递模式</a><ul><li><a href="#4.1">4.1点对点模式（PTP）</a></li><li><a href="#4.2">4.2发布-订阅模型（Pub/Sub）</a></li></ul></li></ul></blockquote><h3 id="1-消息中间件概述"><a href="#1-消息中间件概述" class="headerlink" title="1.消息中间件概述"></a><h3 id="1">1.消息中间件概述</h3></h3><p>&emsp;&emsp;消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。消息中间件就是用在消息队列服务器中用于过滤、区分和根据规则进行转发的程序。<br>&emsp;&emsp;目前在生产环境，使用较多的消息中间件有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等<br>&emsp;&emsp;<img src="https://i.imgur.com/KzxkNjO.jpg" alt=""></p><h3 id="2-消息中间件使用场景"><a href="#2-消息中间件使用场景" class="headerlink" title="2.消息中间件使用场景"></a><h3 id="2">2.消息中间件使用场景</h3></h3><p>&emsp;&emsp;消息中间件适用于需要可靠的数据传送的分布式环境。<br>&emsp;&emsp;采用消息中间件机制的系统中，不同的对象之间通过传递消息来激活对方的事件，完成相应的操作。<br>&emsp;&emsp;<img src="https://i.imgur.com/YeIsiIQ.png" alt=""><br>&emsp;&emsp;消息中间件能在不同平台之间通信，它常被用来屏蔽掉各种平台及协议之间的特性，实现应用程序之间的协同，其优点在于能够在客户和服务器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发，这也是它比远程过程调用更进一步的原因。</p><h3 id="3-消息中间件原理"><a href="#3-消息中间件原理" class="headerlink" title="3.消息中间件原理"></a><h3 id="3">3.消息中间件原理</h3></h3><p>&emsp;&emsp;要了解消息中间件的原理，先了解MOM（面向消息的中间件）。<br>&emsp;&emsp;面向消息的中间件（MOM），提供了以松散耦合的灵活方式集成应用程序的一种机制。它们提供了基于存储和转发的应用程序之间的异步数据发送，即应用程序彼此不直接通信，而是与作为中介的MOM通信。MOM提供了有保证的消息发送（至少是在尽可能地做到这一点），应用程序开发人员无需了解远程过程调用（PRC）和网络/通信协议的细节。<br>&emsp;&emsp;消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。<br>&emsp;&emsp;<img src="https://i.imgur.com/gYBCD4x.png" alt="">  </p><h3 id="4-消息中间件传递模式"><a href="#4-消息中间件传递模式" class="headerlink" title="4.消息中间件传递模式"></a><h3 id="4">4.消息中间件传递模式</h3></h3><h4 id="4-1点对点模式（PTP）"><a href="#4-1点对点模式（PTP）" class="headerlink" title="4.1点对点模式（PTP）"></a><h4 id="4.1">4.1点对点模式（PTP）</h4></h4><p>&emsp;&emsp;PTP模式包含消息队列（Queue），发送者(Sender)。接收者(Receiver),每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，而且队列可以是持久的，以保证在消息服务出现故障时仍然能够传递消息，直到他们被消费或超时。<br>&emsp;&emsp;<img src="https://i.imgur.com/Qc9g31L.png" alt=""><br>PTP的特点：</p><ul><li>每个消息只有一个消费者（cunsumes）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者之间在时间上没有依赖性，也就是发送者发送消息后，不管接收者是否接收消息或者接收者服务是否在运行，都不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功<h4 id="4-2发布-订阅模型（Pub-Sub）"><a href="#4-2发布-订阅模型（Pub-Sub）" class="headerlink" title="4.2发布-订阅模型（Pub/Sub）"></a><h4 id="4.2">4.2发布-订阅模型（Pub/Sub）</h4></h4>&emsp;&emsp;发布-订阅模型（Pub/Sub）包含三个角色：主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。<br>&emsp;&emsp;<img src="https://i.imgur.com/YgmRxWr.png" alt=""><br>Pub/Sub的特点</li><li>每个消息可以有多个消费者</li><li>发送者和接收者之间在时间上存在依赖性，针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。  </li></ul><p>&emsp;&emsp;为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。<br>&emsp;&emsp;如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式之消息中间件&quot;&gt;&lt;a href=&quot;#分布式之消息中间件&quot; class=&quot;headerlink&quot; title=&quot;分布式之消息中间件&quot;&gt;&lt;/a&gt;分布式之消息中间件&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;
      
    
    </summary>
    
      <category term="消息队列" scheme="https://catalpaflat.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="消息队列" scheme="https://catalpaflat.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
